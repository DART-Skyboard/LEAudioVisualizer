<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>[gsap/threejs/inertia] ❍ Audio-Reactive Maze Visualizer</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        /* Copied and adapted from visualizer's style.css and lemazeashbackup.html internal styles */
        @import url("https://fonts.cdnfonts.com/css/thegoodmonolith");

        :root {
          --bg-color: #12100f;
          --grid-color: rgba(255, 240, 230, 0.05);
          --text-primary: #f3ede9;
          --text-secondary: #c2b8b2;
          --text-highlight: #ff4e42; /* Main accent */
          --accent-primary: #ff4e42;
          --accent-secondary: #c2362f;
          --accent-tertiary: #ffb3ab;
          --panel-bg: rgba(30, 26, 24, 0.85); /* Slightly more opaque */
          --panel-border: rgba(255, 78, 66, 0.4); /* Brighter border */
          --panel-highlight: rgba(255, 78, 66, 0.15);
          --scanner-line: rgba(255, 78, 66, 0.7);
        }

        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        body {
          background-color: var(--bg-color);
          color: var(--text-primary);
          font-family: "TheGoodMonolith", monospace;
          overflow: hidden;
          height: 100vh;
          text-transform: uppercase;
          font-size: 1rem; /* Base font size for UI consistency */
        }

        button,
        input,
        select,
        textarea {
          font-family: inherit;
          color: var(--text-primary); /* Ensure form elements inherit text color */
        }
        
        input[type="number"] {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            width: 60px; /* Adjust width as needed */
        }

        .space-background {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: url("https://assets.codepen.io/7558/space-bg-002.jpg");
          background-size: cover;
          background-position: center;
          z-index: 0;
          opacity: 0.7; /* Slightly reduced for better foreground visibility */
        }

        #three-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 1;
          cursor: grab;
        }

        #three-container:active {
          cursor: grabbing;
        }

        .interface-container {
          position: relative; /* Changed from fixed to allow content scroll if necessary, though overflow hidden on body */
          width: 100%;
          height: 100vh;
          z-index: 2;
          pointer-events: none; /* Allows clicks to pass through to Three.js canvas unless an element below has pointer-events: auto */
          padding: 1rem; /* Unified padding */
          display: flex;
          flex-direction: column;
          justify-content: space-between;
        }

        .grid-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: linear-gradient(
              to right,
              var(--grid-color) 1px,
              transparent 1px
            ),
            linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
          background-size: 30px 30px; /* Slightly smaller grid */
          pointer-events: none;
          z-index: 0; /* Behind UI panels but above background */
        }

        .header {
          display: flex;
          justify-content: space-between;
          padding: 0.5rem 1rem; /* Adjusted padding */
          position: relative; /* Ensure it's above grid if z-index not enough */
          z-index: 5;
        }

        .header-item {
          font-size: 0.7rem; /* Smaller header text */
          color: var(--text-secondary);
        }
        
        /* Central Scanner Frame - adapted from visualizer */
        .scanner-frame {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 350px; /* Adjusted size */
          height: 350px;
          border: 1px solid var(--accent-primary);
          box-shadow: 0 0 15px var(--accent-primary), inset 0 0 15px var(--accent-primary);
          pointer-events: none;
          z-index: 3; /* Above grid, below panels */
        }

        .scanner-frame::before,
        .scanner-frame::after,
        .scanner-frame .corner-tl,
        .scanner-frame .corner-tr,
        .scanner-frame .corner-bl,
        .scanner-frame .corner-br {
          content: "";
          position: absolute;
          width: 20px;
          height: 20px;
          border-color: var(--accent-primary);
          border-style: solid;
        }
        .scanner-frame .corner-tl { top: -2px; left: -2px; border-width: 2px 0 0 2px; }
        .scanner-frame .corner-tr { top: -2px; right: -2px; border-width: 2px 2px 0 0; }
        .scanner-frame .corner-bl { bottom: -2px; left: -2px; border-width: 0 0 2px 2px; }
        .scanner-frame .corner-br { bottom: -2px; right: -2px; border-width: 0 2px 2px 0; }

        .scanner-id {
          position: absolute;
          bottom: -25px; /* Adjusted position */
          left: 0;
          font-size: 0.65rem;
          color: var(--accent-primary);
          background-color: var(--bg-color); /* Add bg to prevent overlap issues */
          padding: 2px 4px;
        }

        .scanner-id-right {
          position: absolute;
          bottom: -25px;
          right: 0;
          font-size: 0.65rem;
          color: var(--accent-primary);
          background-color: var(--bg-color);
          padding: 2px 4px;
        }

        /* General Panel Styling - adapted from visualizer */
        .ui-panel, .data-panel, .control-panel, .terminal-panel, .spectrum-analyzer {
          background: var(--panel-bg);
          border: 1px solid var(--panel-border);
          border-radius: 5px;
          padding: 0.8rem;
          backdrop-filter: blur(10px);
          -webkit-backdrop-filter: blur(10px);
          pointer-events: auto; /* Crucial for interaction */
          box-shadow: 0 0 15px rgba(0,0,0,0.3);
          position: absolute; /* Needed for Draggable */
          z-index: 10; /* Default z-index for panels */
        }
        
        .panel-header-title {
            font-size: 0.8rem;
            color: var(--accent-primary);
            margin-bottom: 0.75rem;
            display: block; /* Make it block for better spacing */
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 0.5rem;
        }

        .panel-handle { /* For drag functionality */
          cursor: move;
          padding: 0.2rem 0.5rem;
          color: var(--accent-secondary);
          font-size: 1.2rem;
          position: absolute;
          top: 0.5rem;
          right: 0.5rem;
        }
        .panel-handle:hover {
            color: var(--accent-primary);
        }
        
        .control-group { margin-bottom: 0.8rem; }
        .control-group label, .control-label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        .control-row { /* For sliders mostly */
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.2rem;
        }
        .control-value { font-size: 0.7rem; color: var(--text-primary); }

        .slider {
          -webkit-appearance: none;
          appearance: none;
          width: 100%;
          height: 6px;
          background: rgba(255, 255, 255, 0.1);
          outline: none;
          border-radius: 3px;
          margin-top: 0.2rem;
        }
        .slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: var(--accent-primary);
          cursor: pointer;
          border: 2px solid var(--bg-color); /* Thumb border */
        }
        .slider::-moz-range-thumb {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: var(--accent-primary);
          cursor: pointer;
          border: 2px solid var(--bg-color);
        }

        .btn {
          flex: 1;
          padding: 0.6rem 0.5rem;
          background: var(--panel-highlight);
          border: 1px solid var(--panel-border);
          color: var(--accent-primary);
          font-size: 0.7rem;
          border-radius: 3px;
          cursor: pointer;
          transition: all 0.2s ease;
          text-transform: uppercase;
        }
        .btn:hover { background: var(--panel-border); color: var(--text-primary); }
        .btn:disabled { background-color: #333; cursor: not-allowed; color: #777; }
        .button-group { display: flex; gap: 0.5rem; margin-top: 0.8rem; }


        /* Maze Controls Panel (Original adapted) */
        #maze-controls-panel {
            width: 280px; /* Adjust as needed */
            top: 20px;
            left: 20px;
        }
        #maze-controls-panel .control-group input[type="number"] { width: 60px; text-align: right; }
        #maze-controls-panel .control-group { display: flex; justify-content: space-between; align-items: center; }


        /* Anomaly Metrics Panels (from visualizer) */
        .data-panel { width: 280px; } /* Consistent width */
        #anomaly-metrics-left { top: 20px; left: calc(20px + 280px + 20px); /* Position next to maze controls */ }
        #anomaly-metrics-right { top: 20px; right: 20px; }

        .data-panel-title { /* Already styled via .panel-header-title */ }
        .data-readouts { margin-top: 0.5rem; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 0.25rem; font-size: 0.7rem; }
        .data-label { color: var(--text-secondary); }
        .data-value { color: var(--text-primary); }
        .data-bar { height: 5px; background: rgba(255, 255, 255, 0.1); margin: 0.5rem 0; border-radius: 3px; }
        .data-bar-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        #status-indicator { font-size: 1.2em; transition: color 0.3s ease; }
        .waveform { width: 100%; height: 40px; margin: 0.5rem 0; background: rgba(0,0,0,0.2); border-radius: 3px; }
        .waveform-canvas { width: 100%; height: 100%; }

        /* Anomaly Controls / Maze Dynamics Panel (New / From Visualizer) */
        #dynamic-controls-panel {
            width: 280px;
            top: calc(20px + 200px + 20px); /* Position below left metrics or maze controls */
            left: 20px;
        }

        /* Terminal Panel (from visualizer) */
        .terminal-panel {
          left: 20px;
          bottom: 20px;
          width: 450px; /* Adjusted width */
          height: 140px; /* Adjusted height */
        }
        .terminal-header { /* Combined with panel-header-title and panel-handle */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--panel-border);
        }
        .terminal-header span:first-child { font-size: 0.8rem; color: var(--accent-primary); }
        #terminal-status { font-size: 0.7rem; color: var(--text-secondary); }
        .terminal-content {
          height: calc(100% - 45px); /* Adjust based on header */
          overflow-y: auto;
          font-size: 0.65rem; /* Smaller terminal font */
          color: var(--text-secondary);
          line-height: 1.5;
        }
        .terminal-line { margin-bottom: 0.2rem; word-break: break-all; }
        .command-line { color: var(--text-primary); } /* Brighter for commands */
        .typing::after { content: "▋"; animation: blink 0.7s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* Audio Spectrum Analyzer Panel (from visualizer) */
        .spectrum-analyzer {
          bottom: 20px;
          right: 20px;
          width: 320px; /* Adjusted width */
        }
        .spectrum-header { /* Combined with panel-header-title and panel-handle */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--panel-border);
        }
        .spectrum-header span:first-child { font-size: 0.8rem; color: var(--accent-primary); }
        .spectrum-content { padding: 0.5rem 0; }
        .spectrum-canvas { width: 100%; height: 80px; display: block; background: rgba(0,0,0,0.1); border-radius: 3px; }
        .audio-controls { display: flex; flex-direction: column; gap: 0.6rem; margin-top: 0.75rem; }
        .audio-file-input { display: none; }
        .audio-file-btn { display: block; text-align: center; } /* Uses .btn styling */
        .audio-file-label {
            padding: 0.5rem; background: rgba(0,0,0,0.2); color: var(--accent-secondary);
            font-size: 0.65rem; border-radius: 3px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .demo-tracks-label { font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.3rem; display: block; }
        .demo-track-buttons { display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .demo-track-btn { padding: 0.4rem 0.6rem; font-size: 0.65rem; } /* Uses .btn styling */
        .demo-track-btn.active { background: var(--accent-primary); color: var(--bg-color); border-color: var(--accent-primary); }


        /* Loading Overlay (from visualizer) */
        .loading-overlay {
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background: var(--bg-color); display: flex; justify-content: center; align-items: center;
          z-index: 1000; transition: opacity 0.5s ease-out;
        }
        .loading-container { display: flex; flex-direction: column; align-items: center; }
        .preloader-canvas-container { width: 150px; height: 150px; position: relative; } /* For preloader canvas */
        .preloader-canvas { width: 100%; height: 100%; }
        .loading-text { margin-top: 1rem; color: var(--accent-primary); letter-spacing: 1.5px; font-size: 0.8rem; }

        /* Notification (from visualizer) */
        .notification {
          position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
          background: var(--panel-bg); border: 1px solid var(--panel-border);
          padding: 0.75rem 1.25rem; border-radius: 5px; font-size: 0.75rem;
          color: var(--accent-primary); opacity: 0; transition: opacity 0.3s ease-out, top 0.3s ease-out;
          z-index: 1001; pointer-events: none;
        }
        .notification.show { opacity: 1; top: 30px; }

        /* Floating Particles (placeholder if needed, visualizer uses JS to create these) */
        .floating-particles { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:4; }
        .particle { /* styled by JS */ }
        
        /* Original maze UI panel specific styles if any - mostly covered by .ui-panel now */
        #ui-panel.collapsed #ui-content { display: none; } /* Simple collapse */

    </style>
</head>
<body>

    <!-- Visualizer Backgrounds & Overlays -->
    <div class="space-background"></div>
    <div class="grid-overlay"></div>
    <div id="three-container"></div> <!-- Maze will be rendered here -->

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
      <div class="loading-container">
        <div class="preloader-canvas-container">
          <canvas id="preloader-canvas" class="preloader-canvas" width="180" height="180"></canvas>
        </div>
        <div class="loading-text">INITIALIZING SYSTEM...</div>
      </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">Notification Message</div>

    <!-- Floating Particles Container -->
    <div class="floating-particles" id="floating-particles"></div>

    <!-- Main Interface Container -->
    <div class="interface-container">
      <div class="header">
        <div class="header-item">MAZE VISUALIZER MK.II</div>
        <div class="header-item">SYS.AUDIO.REACTIVE.ENGINE<br />v0.9.beta</div>
        <div class="header-item" id="timestamp">TIME: 00:00:00</div>
      </div>

      <!-- Central Scanner Frame (visual only) -->
      <div class="scanner-frame" id="scanner-frame">
        <div class="corner-tl"></div><div class="corner-tr"></div>
        <div class="corner-bl"></div><div class="corner-br"></div>
        <div class="scanner-id" id="scanner-id-left">MAZE.GENERATOR.ACTIVE</div>
        <div class="scanner-id-right" id="scanner-id-right">PATHFINDER.ENGAGED</div>
      </div>
    </div>

    <!-- Maze Generator Controls (Adapted from original #ui-panel) -->
    <div class="ui-panel" id="maze-controls-panel">
        <div class="panel-header-title">Maze Configuration</div>
        <span class="panel-handle" id="maze-controls-panel-handle">⋮⋮</span>
        <div id="ui-content">
            <div class="control-group">
                <label for="mazeWidth">Width:</label>
                <input type="number" id="mazeWidth" value="12" min="3" max="50">
            </div>
            <div class="control-group">
                <label for="mazeHeight">Height:</label>
                <input type="number" id="mazeHeight" value="12" min="3" max="50">
            </div>
            <div class="control-group">
                <label for="cellSize">Cell Size:</label>
                <input type="number" id="cellSize" value="10" min="1" max="30">
            </div>
             <div class="control-group">
                <label for="wallHeight">Wall Height:</label>
                <input type="number" id="wallHeight" value="8" min="1" max="20">
            </div>
            <div class="button-group">
                <button id="generateBtn" class="btn">Generate Maze</button>
                <button id="solveBtn" class="btn" disabled>Solve Maze</button>
            </div>
            <div class="control-group" style="margin-top: 10px; display: flex; align-items: center; justify-content: flex-start;">
                <input type="checkbox" id="instantSolveCheck" style="width: auto; margin-right: 8px; margin-top:0;">
                <label for="instantSolveCheck" style="margin-bottom: 0; font-size: 0.7rem; display: inline-block; width:auto;">Solve Instantly</label>
            </div>
            <hr style="border: 0; border-top: 1px solid var(--panel-border); margin: 10px 0;">
            <div class="button-group">
                <button id="frameViewBtn" class="btn secondary">Frame View</button>
                <button id="clearBtn" class="btn secondary" style="background-color: #dc3545;">Clear</button>
            </div>
            <!-- Export buttons can be added here if needed -->
        </div>
    </div>

    <!-- Anomaly Metrics Left (Adapted from Visualizer) -->
    <div class="data-panel" id="anomaly-metrics-left">
        <div class="panel-header-title">System Metrics</div>
        <span class="panel-handle" id="metrics-left-handle">⋮⋮</span>
        <div class="data-bar"><div class="data-bar-fill" id="stability-bar" style="width: 75%;"></div></div>
        <div class="data-readouts">
            <div class="data-row"><span class="data-label">STABILITY INDEX:</span><span class="data-value" id="stability-value">75%</span></div>
            <div class="data-row"><span class="data-label">WALL COUNT:</span><span class="data-value" id="wall-count-value">0</span></div>
            <div class="data-row"><span class="data-label">PATH LENGTH:</span><span class="data-value" id="path-length-value">0</span></div>
            <div class="data-row"><span class="data-label">COMPLEXITY:</span><span class="data-value" id="complexity-value">N/A</span></div>
        </div>
         <div id="status-indicator" style="color: var(--accent-primary); text-align: right; margin-top: 5px;">● OPERATIONAL</div>
    </div>
    
    <!-- Anomaly Metrics Right (Adapted from Visualizer for Audio) -->
    <div class="data-panel" id="anomaly-metrics-right">
        <div class="panel-header-title">Audio Analysis</div>
        <span class="panel-handle" id="metrics-right-handle">⋮⋮</span>
        <div class="waveform"><canvas id="waveform-canvas" class="waveform-canvas"></canvas></div>
        <div class="data-readouts">
            <div class="data-row"><span class="data-label">PEAK FREQ:</span><span class="data-value" id="peak-value">0 HZ</span></div>
            <div class="data-row"><span class="data-label">AMPLITUDE:</span><span class="data-value" id="amplitude-value">0.00</span></div>
            <div class="data-row"><span class="data-label">AUDIO ENERGY:</span><span class="data-value" id="audio-energy-value">0.00</span></div>
        </div>
    </div>

    <!-- Maze Dynamics / Anomaly Controls Panel -->
    <div class="control-panel" id="dynamic-controls-panel">
        <div class="panel-header-title">Dynamic Modulators</div>
        <span class="panel-handle" id="dynamic-controls-handle">⋮⋮</span>
        <div class="control-group">
            <div class="control-row"><label class="control-label">WALL DEFORMATION</label><span class="control-value" id="wall-deformation-value">0.0</span></div>
            <input type="range" min="0" max="2" value="0" step="0.05" class="slider" id="wall-deformation-slider">
        </div>
        <div class="control-group">
            <div class="control-row"><label class="control-label">DEFORMATION SPEED</label><span class="control-value" id="deformation-speed-value">0.1</span></div>
            <input type="range" min="0.01" max="0.5" value="0.1" step="0.01" class="slider" id="deformation-speed-slider">
        </div>
        <div class="control-group">
            <div class="control-row"><label class="control-label">COLOR INTENSITY</label><span class="control-value" id="color-intensity-value">0.5</span></div>
            <input type="range" min="0" max="1.5" value="0.5" step="0.05" class="slider" id="color-intensity-slider">
        </div>
         <div class="control-group">
            <div class="control-row"><label class="control-label">AUDIO REACTIVITY</label><span class="control-value" id="audio-reactivity-value">1.0</span></div>
            <input type="range" min="0" max="3" value="1" step="0.1" class="slider" id="audio-reactivity-slider">
        </div>
    </div>
    
    <!-- System Terminal -->
    <div class="terminal-panel" id="terminal-panel">
        <div class="terminal-header">
            <span>SYSTEM TERMINAL</span>
            <span id="terminal-status">STANDBY</span>
        </div>
        <span class="panel-handle" id="terminal-handle">⋮⋮</span>
        <div class="terminal-content" id="terminal-content">
            <div class="terminal-line">SYSTEM BOOTING... MAZE VISUALIZER MK.II ONLINE.</div>
            <div class="terminal-line typing"></div>
        </div>
    </div>

    <!-- Audio Spectrum Analyzer Panel -->
    <div class="spectrum-analyzer" id="spectrum-analyzer-panel">
        <div class="spectrum-header">
            <span>AUDIO SPECTRUM & CONTROLS</span>
        </div>
        <span class="panel-handle" id="spectrum-handle">⋮⋮</span>
        <div class="spectrum-content"><canvas id="spectrum-canvas" class="spectrum-canvas"></canvas></div>
        <div class="audio-controls">
            <div class="demo-tracks">
                <span class="demo-tracks-label">DEMO TRACKS:</span>
                <div class="demo-track-buttons">
                    <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Merkaba.mp3">MERKABA</button>
                    <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Dhamika.mp3">DHAMIKA</button>
                    <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Vacant.mp3">VACANT</button>
                    <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/lxstnght-back_1.mp3">LXSTNGHT</button>
                </div>
            </div>
            <input type="file" id="audio-file-input" class="audio-file-input" accept="audio/*">
            <button class="btn audio-file-btn" id="file-btn">UPLOAD AUDIO FILE</button>
            <div class="audio-file-label" id="file-label">NO FILE SELECTED</div>
            <audio id="audio-player" class="audio-player" crossorigin="anonymous" controls></audio> <!-- Added controls for debugging -->
             <div class="control-group">
                <div class="control-row"><label class="control-label">AUDIO SENSITIVITY</label><span class="control-value" id="audio-sensitivity-value">5.0</span></div>
                <input type="range" min="1" max="10" value="5" step="0.1" class="slider" id="audio-sensitivity-slider">
            </div>
        </div>
    </div>

    <script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/Draggable.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/InertiaPlugin.min.js'></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'; // If export is still needed

        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls, clock;
        let mazeGroup = new THREE.Group();
        let pathObject = null;
        const mazeData = { grid: null, start: null, end: null, solutionPath: null, wallMeshes: [] };
        
        let audioContext = null, audioAnalyser = null, audioSource = null;
        let audioDataArray, frequencyDataArray; // Renamed from visualizer's audioData, frequencyData
        let isAudioInitialized = false, isAudioPlaying = false, audioContextStarted = false;
        let currentAudioElement = null;

        let wallDeformationAmount = 0.0, deformationSpeed = 0.1, colorIntensity = 0.5;
        let audioReactivityFactor = 1.0, audioSensitivityFactor = 5.0;

        // --- UI ELEMENTS ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const preloaderCanvas = document.getElementById('preloader-canvas');
        const notificationElement = document.getElementById('notification');
        const timestampElement = document.getElementById('timestamp');

        // Maze Controls
        const generateBtn = document.getElementById('generateBtn');
        const solveBtn = document.getElementById('solveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const frameViewBtn = document.getElementById('frameViewBtn');
        const instantSolveCheck = document.getElementById('instantSolveCheck');
        const mazeWidthInput = document.getElementById('mazeWidth');
        const mazeHeightInput = document.getElementById('mazeHeight');
        const cellSizeInput = document.getElementById('cellSize');
        const wallHeightInput = document.getElementById('wallHeight');

        // Dynamic Controls
        const wallDeformationSlider = document.getElementById('wall-deformation-slider');
        const wallDeformationValue = document.getElementById('wall-deformation-value');
        const deformationSpeedSlider = document.getElementById('deformation-speed-slider');
        const deformationSpeedValue = document.getElementById('deformation-speed-value');
        const colorIntensitySlider = document.getElementById('color-intensity-slider');
        const colorIntensityValue = document.getElementById('color-intensity-value');
        const audioReactivitySlider = document.getElementById('audio-reactivity-slider');
        const audioReactivityValue = document.getElementById('audio-reactivity-value');

        // Audio Controls
        const audioFileInput = document.getElementById('audio-file-input');
        const fileBtn = document.getElementById('file-btn');
        const fileLabel = document.getElementById('file-label');
        const demoTrackBtns = document.querySelectorAll('.demo-track-btn');
        currentAudioElement = document.getElementById('audio-player'); // Use existing
        const audioSensitivitySlider = document.getElementById('audio-sensitivity-slider');
        const audioSensitivityValue = document.getElementById('audio-sensitivity-value');

        // Metrics Display
        const stabilityValueElement = document.getElementById('stability-value');
        const stabilityBarElement = document.getElementById('stability-bar');
        const wallCountValueElement = document.getElementById('wall-count-value');
        const pathLengthValueElement = document.getElementById('path-length-value');
        const complexityValueElement = document.getElementById('complexity-value');
        const peakValueElement = document.getElementById('peak-value');
        const amplitudeValueElement = document.getElementById('amplitude-value');
        const audioEnergyValueElement = document.getElementById('audio-energy-value');
        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrum-canvas');
        const spectrumCtx = spectrumCanvas.getContext('2d');
        
        // Terminal
        const terminalContent = document.getElementById('terminal-content');
        const terminalTypingLine = terminalContent.querySelector('.typing');
        const terminalStatus = document.getElementById('terminal-status');
        let terminalMessageQueue = [];

        // --- PRELOADER (From Visualizer) ---
        function setupExpandingCirclesPreloader() {
            if (!preloaderCanvas) return;
            const ctx = preloaderCanvas.getContext("2d");
            const centerX = preloaderCanvas.width / 2;
            const centerY = preloaderCanvas.height / 2;
            let time = 0, lastTime = 0;
            const maxRadius = 70, circleCount = 4, dotCount = 16;

            function animatePreloader(timestamp) {
              if (!lastTime) lastTime = timestamp;
              const deltaTime = timestamp - lastTime;
              lastTime = timestamp;
              time += deltaTime * 0.0015; // Slightly faster
              ctx.clearRect(0, 0, preloaderCanvas.width, preloaderCanvas.height);
              ctx.beginPath();
              ctx.arc(centerX, centerY, 2.5, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255, 78, 66, 0.9)";
              ctx.fill();
              for (let c = 0; c < circleCount; c++) {
                const circlePhase = (time * 0.4 + c / circleCount) % 1;
                const radius = circlePhase * maxRadius;
                const opacity = 1 - circlePhase;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 78, 66, ${opacity * 0.25})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                // Optional: dots on circles
                for (let i = 0; i < dotCount; i++) {
                  const angle = (i / dotCount) * Math.PI * 2;
                  const x = centerX + Math.cos(angle) * radius;
                  const y = centerY + Math.sin(angle) * radius;
                  const size = 1.5 * (1 - circlePhase * 0.5);
                  ctx.beginPath();
                  ctx.arc(x, y, size, 0, Math.PI * 2);
                  ctx.fillStyle = `rgba(255, 78, 66, ${opacity * 0.8})`;
                  ctx.fill();
                }
              }
              if (loadingOverlay.style.display !== "none") {
                requestAnimationFrame(animatePreloader);
              }
            }
            requestAnimationFrame(animatePreloader);
        }
        
        // --- NOTIFICATIONS & TERMINAL (From Visualizer) ---
        function showNotification(message, duration = 3000) {
            notificationElement.textContent = message;
            notificationElement.classList.add('show');
            setTimeout(() => {
                notificationElement.classList.remove('show');
            }, duration);
        }

        function addTerminalMessage(message, isCommand = false, typeSpeed = 20) {
            const SCRIPT_PREFIX = "SCRIPT:> ";
            if (isCommand) message = SCRIPT_PREFIX + message;
            
            const existingTyping = terminalContent.querySelector('.typing-active');
            if (existingTyping) {
                 // Add to queue if already typing
                 terminalMessageQueue.push({text: message, isCommand});
                 return;
            }

            const newLine = document.createElement("div");
            newLine.className = `terminal-line ${isCommand ? 'command-line' : ''} typing-active`;
            terminalContent.insertBefore(newLine, terminalTypingLine); // Insert before the permanent blinking cursor
            
            let charIndex = 0;
            function typeChar() {
                if (charIndex < message.length) {
                    newLine.textContent = message.substring(0, charIndex + 1) + (charIndex < message.length -1 ? '▋' : '');
                    charIndex++;
                    terminalContent.scrollTop = terminalContent.scrollHeight;
                    setTimeout(typeChar, typeSpeed);
                } else {
                    newLine.textContent = message; // Remove cursor when done
                    newLine.classList.remove('typing-active');
                    processNextTerminalMessage(); // Check queue
                }
            }
            typeChar();
        }
        
        function processNextTerminalMessage() {
            if (terminalMessageQueue.length > 0) {
                const nextMsg = terminalMessageQueue.shift();
                addTerminalMessage(nextMsg.text, nextMsg.isCommand);
            }
        }


        // --- MAZE LOGIC (Original, might be adapted for audio later) ---
        function createGrid(w, h) { return Array(h).fill(null).map(() => Array(w).fill(null).map(() => ({ N: true, E: true, S: true, W: true, originalVertices: null, mesh: null }))); }
        function generateMazeGrid(width, height) {
            // ... (original maze generation logic - unchanged) ...
            const grid = createGrid(width, height);
            const dOp = { 'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E' };
            const dx = { 'E': 1, 'W': -1, 'N': 0, 'S': 0 };
            const dy = { 'E': 0, 'W': 0, 'N': -1, 'S': 1 };
            const stack = [[Math.floor(Math.random()*width), Math.floor(Math.random()*height)]];
            const visited = new Set([`${stack[0][0]},${stack[0][1]}`]);
            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1];
                const neighbors = [];
                for (const dir of ['N', 'E', 'S', 'W']) {
                    const nx = cx + dx[dir], ny = cy + dy[dir];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited.has(`${nx},${ny}`)) {
                        neighbors.push({ dir, x: nx, y: ny });
                    }
                }
                if (neighbors.length > 0) {
                    const { dir, x: nx, y: ny } = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[cy][cx][dir] = false; grid[ny][nx][dOp[dir]] = false;
                    visited.add(`${nx},${ny}`); stack.push([nx, ny]);
                } else { stack.pop(); }
            }
            return grid;
        }
        function getRandomPerimeterCell(w, h, exclude = null, minDistance = 0) {
            // ... (original logic - unchanged) ...
            const perimeter = [];
            for (let x = 0; x < w; x++) { perimeter.push({ x, y: 0 }); perimeter.push({ x, y: h - 1 }); }
            for (let y = 1; y < h - 1; y++) { perimeter.push({ x: 0, y }); perimeter.push({ x: w - 1, y }); }
            
            let attempts = 0;
            while(attempts < 100) {
                let potentialCells = perimeter;
                if (exclude) {
                    potentialCells = perimeter.filter(p => p.x !== exclude.x || p.y !== exclude.y);
                }
                if(potentialCells.length === 0) return perimeter[0] || {x:0,y:0}; // fallback
                
                const cell = potentialCells[Math.floor(Math.random() * potentialCells.length)];
                
                if (exclude && minDistance > 0) {
                    const dist = Math.sqrt(Math.pow(cell.x - exclude.x, 2) + Math.pow(cell.y - exclude.y, 2));
                    if (dist >= minDistance) {
                        return cell;
                    }
                } else {
                    return cell;
                }
                attempts++;
            }
            return perimeter.filter(p => p.x !== exclude?.x || p.y !== exclude?.y)[0] || perimeter[0] || {x:0,y:0}; // fallback
        }
        function solveMaze(grid, start, end) {
            // ... (original logic - unchanged) ...
            const w = grid[0].length, h = grid.length;
            const dx = { 'E': 1, 'W': -1, 'N': 0, 'S': 0 };
            const dy = { 'E': 0, 'W': 0, 'N': -1, 'S': 1 };
            const q = [start], visited = new Set([`${start.x},${start.y}`]), parentMap = new Map();
            let pathFound = false;
            while (q.length > 0) {
                const curr = q.shift();
                if (curr.x === end.x && curr.y === end.y) { pathFound = true; break; }
                for (const dir of ['N', 'E', 'S', 'W']) {
                    if (!grid[curr.y][curr.x][dir]) {
                        const nx = curr.x + dx[dir], ny = curr.y + dy[dir], key = `${nx},${ny}`;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h && !visited.has(key)) {
                            visited.add(key); parentMap.set(key, `${curr.x},${curr.y}`); q.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            if (!pathFound) return [];
            const path = []; let currKey = `${end.x},${end.y}`;
            while (currKey && parentMap.has(currKey) || (currKey === `${start.x},${start.y}`)) {
                const [x, y] = currKey.split(',').map(Number);
                path.unshift({ x, y }); 
                if (currKey === `${start.x},${start.y}`) break;
                currKey = parentMap.get(currKey);
            }
             if (path.length > 0 && (path[0].x !== start.x || path[0].y !== start.y)) { // Ensure path starts at start
                if(parentMap.size === 0 && start.x === end.x && start.y === end.y) return [start]; // Start and end are same
                return []; // Invalid path
             }
            return path;
        }
        function isPathUninteresting(path) {
             if (!path || path.length < 3) return true;
            const isHorizontal = path.every(p => p.y === path[0].y);
            const isVertical = path.every(p => p.x === path[0].x);
            return isHorizontal || isVertical;
        }

        // --- THREE.JS INITIALIZATION (Merged) ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0e17, 0.035); // Adjusted fog
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 80, 150); // Default maze view

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent background for three-container
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('three-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 600;
            controls.target.set(0,0,0);

            // Lighting (Enhanced from visualizer and maze)
            const ambientLight = new THREE.AmbientLight(0x707080, 0.8); // Softer ambient
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2); // Warmer directional
            dirLight.position.set(70, 100, 60);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 250; dirLight.shadow.camera.bottom = -250;
            dirLight.shadow.camera.left = -250; dirLight.shadow.camera.right = 250;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            scene.add(dirLight);

            // Accent point lights (from visualizer, can be toned down/repositioned)
            const pointLight1 = new THREE.PointLight(varToHex(getCSSVariableValue('--accent-primary')), 0.7, 300, 1.5);
            pointLight1.position.set(50, 30, 50);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(varToHex(getCSSVariableValue('--accent-secondary')), 0.5, 250, 1.8);
            pointLight2.position.set(-50, 20, -50);
            scene.add(pointLight2);
            
            scene.add(mazeGroup);
            clock = new THREE.Clock(); // For animations
            
            // Background particles from visualizer (optional, can be performance intensive)
            // createBackgroundParticles(); // Call if desired

            addEventListeners(); // For maze and general UI
            animate();
            addTerminalMessage("3D RENDERER INITIALIZED.", false, 10);
        }
        
        // Helper to convert CSS variable like 'rgb(r, g, b)' or '#rrggbb' to hex
        function varToHex(colorString) {
            if (colorString.startsWith('#')) return parseInt(colorString.replace("#", "0x"));
            if (colorString.startsWith('rgb')) {
                const parts = colorString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                if (!parts) return 0xffffff; // Default white
                delete parts[0];
                for (let i = 1; i <= 3; ++i) {
                    parts[i] = parseInt(parts[i]).toString(16);
                    if (parts[i].length === 1) parts[i] = '0' + parts[i];
                }
                return parseInt("0x" + parts.join(''));
            }
            return 0xffffff; // Default
        }

        function getCSSVariableValue(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }


        // --- MAZE DRAWING (Adapted for dynamic walls) ---
        function draw3DMaze(grid, start, end, cellSize, wallHeight) {
            clearSceneContent();
            mazeData.wallMeshes = []; // Clear previous wall meshes
            
            const width = grid[0].length;
            const height = grid.length;
            const wallThickness = cellSize * 0.1;

            // Wall material - will be updated by audio
            const wallMat = new THREE.MeshStandardMaterial({
                color: varToHex(getCSSVariableValue('--text-secondary')), // Initial color
                roughness: 0.7,
                metalness: 0.2,
                emissive: 0x000000,
                emissiveIntensity: 0,
            });
            
            const wallSegmentResolution = 1; // Segments for potential deformation, default 1 (solid)

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    
                    // Helper to create a wall
                    const createWall = (posX, posY, posZ, scaleX, scaleY, scaleZ, rotationY = 0) => {
                        // Use BoxGeometry for simplicity, deformation will be faked by noise on shader or simple vertex displacement
                        const wallGeo = new THREE.BoxGeometry(scaleX, scaleY, scaleZ, wallSegmentResolution,1,wallSegmentResolution);
                        const wall = new THREE.Mesh(wallGeo, wallMat.clone()); // Clone material for individual control if needed later
                        wall.position.set(posX, posY, posZ);
                        if (rotationY) wall.rotation.y = rotationY;
                        wall.castShadow = true;
                        wall.receiveShadow = true; // Walls can receive shadows too
                        mazeGroup.add(wall);
                        mazeData.wallMeshes.push(wall);
                        // Store original vertices for deformation
                        wall.userData.originalVertices = wall.geometry.attributes.position.array.slice();
                    };

                    if (cell.E && x < width - 1) { // East wall
                        createWall((x + 1) * cellSize - cellSize/2 + wallThickness/2 , wallHeight / 2, y * cellSize, wallThickness, wallHeight, cellSize);
                    } else if (x === width -1 ) { // Outer East wall if no start/end
                         if (!( (start.x === x && start.y === y && grid[y][x].E === false) || (end.x === x && end.y === y && grid[y][x].E === false) )) {
                            createWall((x + 1) * cellSize - cellSize/2 + wallThickness/2, wallHeight / 2, y * cellSize, wallThickness, wallHeight, cellSize);
                         }
                    }


                    if (cell.S && y < height - 1) { // South wall
                        createWall(x * cellSize, wallHeight / 2, (y + 1) * cellSize - cellSize/2 + wallThickness/2, cellSize, wallHeight, wallThickness);
                    } else if (y === height - 1) { // Outer South wall if no start/end
                         if (!( (start.x === x && start.y === y && grid[y][x].S === false) || (end.x === x && end.y === y && grid[y][x].S === false) )) {
                            createWall(x * cellSize, wallHeight / 2, (y + 1) * cellSize - cellSize/2 + wallThickness/2, cellSize, wallHeight, wallThickness);
                         }
                    }
                    
                     // Always draw North walls for the first row (y=0) unless it's a start/end opening
                    if (y === 0) {
                        if (!( (start.x === x && start.y === y && grid[y][x].N === false) || (end.x === x && end.y === y && grid[y][x].N === false) )) {
                             createWall(x * cellSize, wallHeight / 2, y * cellSize - cellSize/2 - wallThickness/2, cellSize, wallHeight, wallThickness);
                        }
                    }
                    // Always draw West walls for the first col (x=0) unless it's a start/end opening
                    if (x === 0) {
                         if (!( (start.x === x && start.y === y && grid[y][x].W === false) || (end.x === x && end.y === y && grid[y][x].W === false) )) {
                             createWall(x * cellSize - cellSize/2 - wallThickness/2, wallHeight / 2, y * cellSize, wallThickness, wallHeight, cellSize);
                        }
                    }
                }
            }
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(width * cellSize, height * cellSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x403833, roughness: 0.9, metalness: 0.1 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -wallThickness/2; // Slightly below walls
            floor.receiveShadow = true;
            mazeGroup.add(floor);

            // Start/End Markers
            [start, end].forEach((point, index) => {
                const markerGeo = new THREE.CylinderGeometry(cellSize * 0.3, cellSize * 0.3, wallHeight * 0.5, 16);
                const markerMat = new THREE.MeshStandardMaterial({
                    color: index === 0 ? 0x44ff44 : 0xff4444, // Green for start, Red for end
                    emissive: index === 0 ? 0x22aa22 : 0xaa2222,
                    emissiveIntensity: 1,
                    roughness: 0.4
                });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.set(point.x * cellSize, wallHeight * 0.25, point.y * cellSize);
                marker.castShadow = true;
                mazeGroup.add(marker);
            });

            // Center the mazeGroup (important for OrbitControls and general positioning)
            const box = new THREE.Box3().setFromObject(mazeGroup);
            const center = box.getCenter(new THREE.Vector3());
            mazeGroup.position.sub(center); // This moves the group so its geometric center is at (0,0,0)
             // Then, explicitly set the group's position if you want it elsewhere, e.g., mazeGroup.position.set(0, 0, 0);
            
            addTerminalMessage(`MAZE GENERATED: ${width}x${height}, ${mazeData.wallMeshes.length} WALLS.`);
            updateMazeMetrics();
        }
        
        // --- PATH DRAWING (Original, colors can be made reactive) ---
        function drawAnimatedPath(path, cellSize) { /* ... original ... */ 
            clearPathObject();
            if (!path || path.length < 1) return;

            pathObject = new THREE.Group();
            pathObject.name = 'solution_path_group';
            mazeGroup.add(pathObject); // Add to mazeGroup so it's centered with the maze

            const pathMat = new THREE.MeshStandardMaterial({
                color: varToHex(getCSSVariableValue('--accent-tertiary')), 
                emissive: varToHex(getCSSVariableValue('--accent-primary')), emissiveIntensity: 1,
                side: THREE.DoubleSide, depthTest: false, transparent: true, opacity: 0.9,
                roughness: 0.5
            });
            const pathGeo = new THREE.BoxGeometry(cellSize * 0.7, 0.2, cellSize * 0.7);


            let i = 0;
            const baseInterval = 50; 
            
            function addSegment() {
                if (i >= path.length) {
                    addTerminalMessage("PATH SOLUTION ANIMATION COMPLETE.");
                    return;
                }
                const cell = path[i];
                const segment = new THREE.Mesh(pathGeo, pathMat); // Use unique material if colors change per segment
                segment.position.set(
                    cell.x * cellSize, 0.1, cell.y * cellSize // Centered with mazeGroup already
                );
                pathObject.add(segment);
                i++;
                
                let currentInterval = baseInterval;
                if(isAudioPlaying && audioAnalyser){
                    let sum = 0;
                    audioAnalyser.getByteFrequencyData(frequencyDataArray); // Assuming frequencyDataArray is populated
                    for(let k=0; k<frequencyDataArray.length/4; k++) sum += frequencyDataArray[k]; // Low frequencies
                    let avg = sum / (frequencyDataArray.length/4);
                    currentInterval = baseInterval / (1 + (avg/255 * audioReactivityFactor * 0.5)); // Speed up with bass
                    currentInterval = Math.max(10, currentInterval); // Cap minimum interval
                }
                setTimeout(addSegment, currentInterval);
            }
            addSegment();
        }
        function drawInstantPath(path, cellSize) { /* ... original ... */
            clearPathObject();
            if (!path || path.length < 1) return;

            pathObject = new THREE.Group();
            pathObject.name = 'solution_path_group';
            mazeGroup.add(pathObject);

            const pathMat = new THREE.MeshStandardMaterial({
                color: varToHex(getCSSVariableValue('--accent-tertiary')), 
                emissive: varToHex(getCSSVariableValue('--accent-primary')), emissiveIntensity: 1,
                side: THREE.DoubleSide, depthTest: false, transparent: true, opacity: 0.9,
                roughness: 0.5
            });
            const pathGeo = new THREE.BoxGeometry(cellSize * 0.7, 0.2, cellSize * 0.7);

            for (const cell of path) {
                const segment = new THREE.Mesh(pathGeo, pathMat.clone());
                 segment.position.set(
                    cell.x * cellSize, 0.1, cell.y * cellSize
                );
                pathObject.add(segment);
            }
            addTerminalMessage("PATH SOLUTION DRAWN INSTANTLY.");
        }
        
        // --- AUDIO PROCESSING (Adapted from Visualizer) ---
        function initAudioSystem() {
            if (isAudioInitialized) return true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 1024; // Smaller FFT for less detail but faster processing
                audioAnalyser.smoothingTimeConstant = 0.7;
                audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                frequencyDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                // Don't connect analyser to destination directly if you want audio player to control volume/output
                // audioAnalyser.connect(audioContext.destination); 
                isAudioInitialized = true;
                addTerminalMessage("AUDIO SUBSYSTEM INITIALIZED.");
                terminalStatus.textContent = "AUDIO READY";
                return true;
            } catch (error) {
                console.error("Audio initialization error:", error);
                addTerminalMessage("ERROR: AUDIO SUBSYSTEM FAILED TO INITIALIZE. " + error.message, true);
                showNotification("AUDIO SYSTEM ERROR");
                terminalStatus.textContent = "AUDIO ERROR";
                return false;
            }
        }

        function ensureAudioContextStarted() {
            if (!audioContext) {
                if (!initAudioSystem()) return false;
            }
            if (audioContext.state === "suspended") {
                audioContext.resume().then(() => {
                    if (!audioContextStarted) {
                        audioContextStarted = true;
                        addTerminalMessage("AUDIO CONTEXT RESUMED.");
                    }
                }).catch(err => {
                    addTerminalMessage("ERROR: FAILED TO RESUME AUDIO CONTEXT. " + err.message, true);
                });
            } else {
                audioContextStarted = true;
            }
            return audioContextStarted;
        }
        
        function setupAudioSource(audioElement) {
            if (!ensureAudioContextStarted()) {
                addTerminalMessage("ERROR: AUDIO CONTEXT NOT READY.", true);
                return false;
            }
            if (audioSource) { // Disconnect previous source if any
                audioSource.disconnect();
            }
            try {
                audioSource = audioContext.createMediaElementSource(audioElement);
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination); // Connect analyser output to speakers
                addTerminalMessage("AUDIO SOURCE CONNECTED: " + (audioElement.src.substring(0,50) || "HTMLMediaElement"));
                return true;
            } catch (error) {
                 addTerminalMessage("ERROR SETTING UP AUDIO SOURCE: " + error.message, true);
                 console.error("Error setting up audio source:", error);
                 return false;
            }
        }

        function loadAudioFile(file) {
            if (!initAudioSystem()) return;
            const fileURL = URL.createObjectURL(file);
            currentAudioElement.src = fileURL;
            fileLabel.textContent = file.name.length > 25 ? file.name.substring(0,22) + "..." : file.name;
            currentAudioElement.oncanplaythrough = () => { // Wait till it can play
                if (setupAudioSource(currentAudioElement)) {
                    currentAudioElement.play().catch(e => addTerminalMessage("Playback error: " + e.message, true));
                    isAudioPlaying = true;
                    terminalStatus.textContent = "PLAYING";
                }
            };
            currentAudioElement.onerror = () => {
                addTerminalMessage(`ERROR LOADING AUDIO FILE: ${file.name}`, true);
                fileLabel.textContent = "LOAD ERROR";
                terminalStatus.textContent = "AUDIO ERROR";
            };
            addTerminalMessage(`LOADING AUDIO FILE: ${file.name}`);
        }

        function loadDemoTrack(url) {
            if (!initAudioSystem()) return;
            currentAudioElement.src = url;
            const filename = url.split("/").pop();
            fileLabel.textContent = filename.length > 25 ? filename.substring(0,22) + "..." : filename;
            
            currentAudioElement.oncanplaythrough = () => {
                 if (setupAudioSource(currentAudioElement)) {
                    currentAudioElement.play().catch(e => addTerminalMessage("Playback error: " + e.message, true));
                    isAudioPlaying = true;
                    terminalStatus.textContent = "PLAYING";
                }
            };
             currentAudioElement.onerror = () => {
                addTerminalMessage(`ERROR LOADING DEMO: ${filename}`, true);
                fileLabel.textContent = "LOAD ERROR";
                terminalStatus.textContent = "AUDIO ERROR";
            };
            addTerminalMessage(`LOADING DEMO TRACK: ${filename}`);
        }
        
        currentAudioElement.onplay = () => { isAudioPlaying = true; terminalStatus.textContent = "PLAYING"; };
        currentAudioElement.onpause = () => { isAudioPlaying = false; terminalStatus.textContent = "PAUSED"; };
        currentAudioElement.onended = () => { isAudioPlaying = false; terminalStatus.textContent = "AUDIO READY"; };


        // --- UI HANDLERS & HELPERS ---
        function updateMazeMetrics() {
            wallCountValueElement.textContent = mazeData.wallMeshes.length;
            pathLengthValueElement.textContent = mazeData.solutionPath ? mazeData.solutionPath.length : 0;
            // Basic complexity: (width * height) / (path length if > 0)
            let complexity = "N/A";
            if (mazeData.grid && mazeData.solutionPath && mazeData.solutionPath.length > 0) {
                complexity = ((mazeData.grid[0].length * mazeData.grid.length * 10) / mazeData.solutionPath.length).toFixed(1);
            }
            complexityValueElement.textContent = complexity;
        }

        function clearPathObject() {
            if (pathObject) {
                pathObject.traverse(child => {
                    if (child.isMesh) { child.geometry.dispose(); child.material.dispose(); }
                });
                mazeGroup.remove(pathObject); pathObject = null;
            }
        }
        function clearSceneContent() {
            clearPathObject();
            mazeData.wallMeshes.forEach(wall => {
                if (wall.geometry) wall.geometry.dispose();
                if (wall.material) wall.material.dispose();
                mazeGroup.remove(wall);
            });
            mazeData.wallMeshes = [];
            
            // Remove floor and markers if they exist by name or type
            const toRemove = [];
            mazeGroup.children.forEach(child => {
                if(child.isMesh && (child.geometry instanceof THREE.PlaneGeometry || child.geometry instanceof THREE.CylinderGeometry)){
                    toRemove.push(child);
                }
            });
            toRemove.forEach(child => {
                 if (child.geometry) child.geometry.dispose();
                 if (child.material) child.material.dispose();
                 mazeGroup.remove(child);
            });

            mazeData.grid = null;
            solveBtn.disabled = true;
            updateMazeMetrics();
            addTerminalMessage("SCENE CLEARED.");
        }
        
        function handleGenerate() {
            generateBtn.disabled = true; generateBtn.textContent = 'Generating...';
            addTerminalMessage("INITIATING MAZE GENERATION PROTOCOL...");

            setTimeout(() => { // Simulate delay for complex generation feel
                const width = parseInt(mazeWidthInput.value);
                const height = parseInt(mazeHeightInput.value);
                const cellSize = parseFloat(cellSizeInput.value);
                const wallH = parseFloat(wallHeightInput.value);

                let attempts = 0, isGoodMaze = false;
                do {
                    mazeData.grid = generateMazeGrid(width, height);
                    const min_dist = Math.max(width, height) / 2.5; // Slightly less strict min_dist
                    mazeData.start = getRandomPerimeterCell(width, height);
                    mazeData.end = getRandomPerimeterCell(width, height, mazeData.start, min_dist);
                    mazeData.solutionPath = solveMaze(mazeData.grid, mazeData.start, mazeData.end);
                    if (mazeData.solutionPath && mazeData.solutionPath.length > 0 && !isPathUninteresting(mazeData.solutionPath)) {
                        isGoodMaze = true;
                    }
                    attempts++;
                } while (!isGoodMaze && attempts < 30); // Reduced attempts for faster UI response

                if (!isGoodMaze) addTerminalMessage("WARNING: Could not generate a complex maze after " + attempts + " attempts. Using last.", true);
                
                draw3DMaze(mazeData.grid, mazeData.start, mazeData.end, cellSize, wallH);
                
                solveBtn.disabled = false;
                frameView();
                generateBtn.disabled = false; generateBtn.textContent = 'Generate Maze';
                showNotification("New Maze Generated!");
            }, 100); // Short delay
        }

        function handleSolve() {
            if (!mazeData.solutionPath || mazeData.solutionPath.length === 0) {
                showNotification("No solution found for this maze!");
                addTerminalMessage("ERROR: NO SOLUTION PATH AVAILABLE.", true);
                return;
            }
            const cellSize = parseFloat(cellSizeInput.value);
            addTerminalMessage("INITIATING PATH SOLUTION SEQUENCE...");
            if (instantSolveCheck.checked) {
                drawInstantPath(mazeData.solutionPath, cellSize);
            } else {
                drawAnimatedPath(mazeData.solutionPath, cellSize);
            }
        }
        
        function frameView() {
            if (mazeGroup.children.length === 0 && mazeData.wallMeshes.length === 0) return;
            
            // Calculate bounding box of mazeGroup children, excluding the pathObject if it exists
            const tempGroup = new THREE.Group();
            mazeGroup.children.forEach(child => {
                if (child !== pathObject) { // Exclude path for framing
                    tempGroup.add(child.clone()); // Cloning to avoid modifying original scene graph for bbox calculation
                }
            });
            if (tempGroup.children.length === 0) return; // Nothing to frame

            const box = new THREE.Box3().setFromObject(tempGroup);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3()); // This center is in mazeGroup's local space
            
            const worldCenter = center.clone().applyMatrix4(mazeGroup.matrixWorld); // Transform to world space

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.8; // Zoom out a bit more

            controls.target.copy(worldCenter);
            
            // Position camera relative to the world center
            const offset = new THREE.Vector3(0, cameraZ * 0.6, cameraZ); // Default viewing angle
            const newCamPos = worldCenter.clone().add(offset);

            gsap.to(camera.position, {
                x: newCamPos.x, y: newCamPos.y, z: newCamPos.z,
                duration: 1, ease: "power2.out",
                onUpdate: () => controls.update()
            });
            gsap.to(controls.target, {
                x: worldCenter.x, y: worldCenter.y, z: worldCenter.z,
                duration: 1, ease: "power2.out"
            });
            addTerminalMessage("CAMERA VIEW FRAMED ON MAZE.");
        }


        // --- ANIMATION LOOP (Merged) ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            controls.update(delta); // Pass delta for damping

            let audioLevel = 0; // Normalized 0-1
            let bassLevel = 0; // Normalized 0-1 for bass frequencies
            let midLevel = 0;
            let trebleLevel = 0;

            if (isAudioPlaying && audioAnalyser && frequencyDataArray) {
                audioAnalyser.getByteFrequencyData(frequencyDataArray);
                audioAnalyser.getByteTimeDomainData(audioDataArray); // For waveform

                let sum = 0;
                let bassSum = 0, midSum = 0, trebleSum = 0;
                const bassEndIndex = Math.floor(frequencyDataArray.length * 0.15); // Up to ~15% for bass
                const midEndIndex = Math.floor(frequencyDataArray.length * 0.5);  // 15% to 50% for mids

                for (let i = 0; i < frequencyDataArray.length; i++) {
                    sum += frequencyDataArray[i];
                    if (i < bassEndIndex) bassSum += frequencyDataArray[i];
                    else if (i < midEndIndex) midSum += frequencyDataArray[i];
                    else trebleSum += frequencyDataArray[i];
                }
                audioLevel = (sum / frequencyDataArray.length / 255) * (audioSensitivityFactor / 5);
                bassLevel = (bassSum / bassEndIndex / 255) * (audioSensitivityFactor / 5);
                midLevel = (midSum / (midEndIndex - bassEndIndex) / 255) * (audioSensitivityFactor / 5);
                trebleLevel = (trebleSum / (frequencyDataArray.length - midEndIndex) / 255) * (audioSensitivityFactor / 5);


                // Update UI readouts for audio
                peakValueElement.textContent = `${(audioAnalyser.fftSize > 0 ? (frequencyDataArray.indexOf(Math.max(...frequencyDataArray)) * audioContext.sampleRate / audioAnalyser.fftSize) : 0).toFixed(0)} HZ`;
                amplitudeValueElement.textContent = audioLevel.toFixed(2);
                audioEnergyValueElement.textContent = (bassLevel * 100).toFixed(1); // Example using bass for "energy"

                // Draw visualizations
                drawWaveformVisualizer(audioDataArray);
                drawSpectrumVisualizer(frequencyDataArray);

                // Apply audio reactivity to maze walls
                mazeData.wallMeshes.forEach(wall => {
                    const currentDeform = wallDeformationAmount * audioReactivityFactor * (bassLevel * 0.6 + midLevel * 0.3 + trebleLevel * 0.1); // Weighted deformation
                    const speed = deformationSpeed * (1 + audioLevel * 0.5);

                    if (currentDeform > 0.01 && wall.userData.originalVertices) {
                        const positions = wall.geometry.attributes.position.array;
                        const originalPos = wall.userData.originalVertices;
                        for (let i = 0; i < positions.length; i += 3) {
                            const noiseFactor = (Math.sin(originalPos[i] * 0.5 + elapsedTime * speed) + Math.cos(originalPos[i+2] * 0.5 + elapsedTime * speed)) * 0.5;
                            // Deform along normals (approx for BoxGeometry - primarily X or Z axis for faces)
                            // This is a simplified deformation. True normal-based deformation for Box requires more work or custom geometry.
                            if (Math.abs(wall.geometry.attributes.normal.array[i]) > 0.5) { // X-normal
                                positions[i] = originalPos[i] + noiseFactor * currentDeform * Math.sign(originalPos[i]);
                            } else if (Math.abs(wall.geometry.attributes.normal.array[i+2]) > 0.5) { // Z-normal
                                positions[i+2] = originalPos[i+2] + noiseFactor * currentDeform * Math.sign(originalPos[i+2]);
                            }
                        }
                        wall.geometry.attributes.position.needsUpdate = true;
                       // wall.geometry.computeVertexNormals(); // Can be expensive
                    } else if (wall.userData.originalVertices) { // Reset if no deformation
                        wall.geometry.attributes.position.array.set(wall.userData.originalVertices);
                        wall.geometry.attributes.position.needsUpdate = true;
                    }

                    // Color reaction
                    const h = (0 + bassLevel * 30) % 360 / 360; // Hue shifts with bass (red-orange)
                    const s = 0.8 + midLevel * 0.2; // Saturation increases with mids
                    const l = 0.4 + trebleLevel * 0.3; // Lightness increases with treble
                    wall.material.color.setHSL(h, s, Math.min(0.8, l));
                    wall.material.emissive.setHSL(h, s, Math.min(0.5, l * 0.5 * colorIntensity * audioReactivityFactor));
                    wall.material.emissiveIntensity = midLevel * colorIntensity * 2.0 * audioReactivityFactor;
                });
            } else { // No audio playing, reset wall appearance gradually or instantly
                 mazeData.wallMeshes.forEach(wall => {
                    if (wall.userData.originalVertices) {
                        wall.geometry.attributes.position.array.set(wall.userData.originalVertices);
                        wall.geometry.attributes.position.needsUpdate = true;
                    }
                    wall.material.color.set(varToHex(getCSSVariableValue('--text-secondary')));
                    wall.material.emissive.set(0x000000);
                    wall.material.emissiveIntensity = 0;
                 });
            }
            
            // Update Stability Bar (example visual)
            const stability = 50 + (audioLevel * 50); // Example, make it more meaningful
            stabilityBarElement.style.width = `${Math.min(100, stability)}%`;
            stabilityValueElement.textContent = `${Math.min(100, stability).toFixed(0)}%`;


            renderer.render(scene, camera);
            updateTimestampDisplay();
        }
        
        // --- VISUALIZER DRAWING FUNCTIONS (Waveform, Spectrum) ---
        function drawWaveformVisualizer(data) {
            const width = waveformCanvas.width;
            const height = waveformCanvas.height;
            waveformCtx.clearRect(0, 0, width, height);
            waveformCtx.fillStyle = "rgba(0,0,0,0.1)"; // Darker bg for contrast
            waveformCtx.fillRect(0,0,width,height);
            waveformCtx.beginPath();
            waveformCtx.strokeStyle = getCSSVariableValue('--accent-primary');
            waveformCtx.lineWidth = 1.5;
            const sliceWidth = width / data.length;
            let x = 0;
            for (let i = 0; i < data.length; i++) {
                const v = data[i] / 128.0; // Normalize 0-255 to 0-2
                const y = v * height / 2;
                if (i === 0) waveformCtx.moveTo(x, y);
                else waveformCtx.lineTo(x, y);
                x += sliceWidth;
            }
            waveformCtx.stroke();
        }

        function drawSpectrumVisualizer(data) {
            const width = spectrumCanvas.width;
            const height = spectrumCanvas.height;
            spectrumCtx.clearRect(0, 0, width, height);
            spectrumCtx.fillStyle = "rgba(0,0,0,0.1)";
            spectrumCtx.fillRect(0,0,width,height);
            
            // Logarithmic scale for bars (more bars for lower frequencies)
            const numBars = 64; // Fewer bars for clarity
            const barWidth = width / numBars;
            let x = 0;

            for (let i = 0; i < numBars; i++) {
                 // Map bar index to frequencyData index (logarithmically)
                const percent = i / numBars;
                const logPercent = Math.pow(percent, 2); // Makes lower frequencies take more space
                const freqIndex = Math.floor(logPercent * (data.length / 2)); // Use first half of spectrum data
                
                const barHeight = (data[freqIndex] / 255) * height * (audioSensitivityFactor / 5);
                
                const hue = (i / numBars) * 40; // 0 (red) to 40 (orange/yellow)
                spectrumCtx.fillStyle = `hsl(${hue}, 100%, ${50 + Math.min(20, data[freqIndex]/10)}%)`; // Brighter with intensity
                spectrumCtx.fillRect(x, height - barHeight, barWidth -1 , barHeight);
                x += barWidth;
            }
        }
        function resizeVisualizerCanvases() {
            [waveformCanvas, spectrumCanvas].forEach(canvas => {
                if (canvas) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
            });
        }
        
        // --- EVENT LISTENERS ---
        function addEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
                resizeVisualizerCanvases();
            });
            
            // Maze controls
            generateBtn.addEventListener('click', handleGenerate);
            solveBtn.addEventListener('click', handleSolve);
            clearBtn.addEventListener('click', clearSceneContent);
            frameViewBtn.addEventListener('click', frameView);

            // Dynamic controls
            wallDeformationSlider.addEventListener('input', (e) => {
                wallDeformationAmount = parseFloat(e.target.value);
                wallDeformationValue.textContent = wallDeformationAmount.toFixed(2);
            });
            deformationSpeedSlider.addEventListener('input', (e) => {
                deformationSpeed = parseFloat(e.target.value);
                deformationSpeedValue.textContent = deformationSpeed.toFixed(2);
            });
            colorIntensitySlider.addEventListener('input', (e) => {
                colorIntensity = parseFloat(e.target.value);
                colorIntensityValue.textContent = colorIntensity.toFixed(2);
            });
             audioReactivitySlider.addEventListener('input', (e) => {
                audioReactivityFactor = parseFloat(e.target.value);
                audioReactivityValue.textContent = audioReactivityFactor.toFixed(1);
            });

            // Audio controls
            fileBtn.addEventListener('click', () => {
                 if (!audioContextStarted) ensureAudioContextStarted(); // Prompt for interaction if needed
                 audioFileInput.click();
            });
            audioFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) loadAudioFile(e.target.files[0]);
            });
            demoTrackBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!audioContextStarted) ensureAudioContextStarted();
                    demoTrackBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadDemoTrack(btn.dataset.url);
                });
            });
            audioSensitivitySlider.addEventListener('input', (e) => {
                audioSensitivityFactor = parseFloat(e.target.value);
                audioSensitivityValue.textContent = audioSensitivityFactor.toFixed(1);
            });
            
            // Initial values for sliders
            wallDeformationValue.textContent = wallDeformationSlider.value; wallDeformationAmount = parseFloat(wallDeformationSlider.value);
            deformationSpeedValue.textContent = deformationSpeedSlider.value; deformationSpeed = parseFloat(deformationSpeedSlider.value);
            colorIntensityValue.textContent = colorIntensitySlider.value; colorIntensity = parseFloat(colorIntensitySlider.value);
            audioReactivityValue.textContent = audioReactivitySlider.value; audioReactivityFactor = parseFloat(audioReactivitySlider.value);
            audioSensitivityValue.textContent = audioSensitivitySlider.value; audioSensitivityFactor = parseFloat(audioSensitivitySlider.value);


            // Make panels draggable
            Draggable.create("#maze-controls-panel", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#maze-controls-panel-handle"});
            Draggable.create("#anomaly-metrics-left", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#metrics-left-handle"});
            Draggable.create("#anomaly-metrics-right", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#metrics-right-handle"});
            Draggable.create("#dynamic-controls-panel", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#dynamic-controls-handle"});
            Draggable.create("#terminal-panel", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#terminal-handle"});
            Draggable.create("#spectrum-analyzer-panel", {type:"x,y", edgeResistance:0.65, bounds:document.body, inertia:true, throwResistance: 2500, trigger: "#spectrum-handle"});
        }
        
        function updateTimestampDisplay() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            timestampElement.textContent = `TIME: ${hours}:${minutes}:${seconds}`;
        }

        // --- INITIALIZATION ---
        function main() {
            setupExpandingCirclesPreloader();
            setTimeout(() => {
                loadingOverlay.style.opacity = 0;
                setTimeout(() => { 
                    loadingOverlay.style.display = 'none'; 
                    initAudioSystem(); // Init audio early but don't require interaction yet
                    terminalStatus.textContent = "ONLINE";
                    showNotification("System Online. Audio Ready.", 4000);
                }, 500);
                
                initThree();
                handleGenerate(); // Generate initial maze
                resizeVisualizerCanvases();
                addTerminalMessage("SYSTEM INITIALIZED. AWAITING COMMANDS.");

            }, 2500); // Preloader duration
        }
        
        main();

    </script>
</body>
</html>