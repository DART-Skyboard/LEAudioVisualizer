<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>[gsap/threejs/inertia] ❍ Audio-Reactive Maze Visualizer</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        /* Copied and adapted from visualizer's style.css and lemazeashbackup.html internal styles */
        @import url("https://fonts.cdnfonts.com/css/thegoodmonolith");

     :root {
    /* Deep, inky blue background matching the sky behind the clouds */
    --bg-color: #0d1b30;
    
    /* Very subtle bluish grid overlaid on the background */
    --grid-color: rgba(173, 216, 230, 0.05);
    
    /* Bright, slightly cool‐toned primary text */
    --text-primary: #eaf4fc;
    
    /* Muted steel‐blue for secondary text */
    --text-secondary: #a1cbe8;
    
    /* Main highlight / call-out color: a vivid sky-blue */
    --text-highlight: #7fbfff;
    
    /* Primary accent (buttons, sliders, etc.) */
    --accent-primary: #4dabf7;
    
    /* Secondary accent for less-emphatic UI elements */
    --accent-secondary: #2e88f7;
    
    /* Tertiary accent for subtle highlights or backgrounds */
    --accent-tertiary: #81d4fa;
    
    /* Semi-opaque dark navy panel backgrounds */
    --panel-bg: rgba(13, 27, 44, 0.85);
    
    /* Panel borders in a softly glowing cyan */
    --panel-border: rgba(127, 191, 255, 0.4);
    
    /* Light panel highlight when hovered/active */
    --panel-highlight: rgba(127, 191, 255, 0.15);
    
    /* Scanner/overlay line in a brighter cyan */
    --scanner-line: rgba(127, 191, 255, 0.7);
}
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        body {
          background-color: var(--bg-color);
          color: var(--text-primary);
          font-family: "TheGoodMonolith", monospace;
          overflow: hidden;
          height: 100vh;
          text-transform: uppercase;
          font-size: 1rem; /* Base font size for UI consistency */
        }

        button,
        input,
        select,
        textarea {
          font-family: inherit;
          color: var(--text-primary); /* Ensure form elements inherit text color */
        }
        
        input[type="number"] {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            width: 60px; /* Adjust width as needed */
        }

        .space-background {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: url("static/bluesky.jpg");
          background-size: cover;
          background-position: center;
          z-index: 0;
          opacity: 0.7; /* Slightly reduced for better foreground visibility */
        }

        #three-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 1;
          cursor: grab;
        }

        #three-container:active {
          cursor: grabbing;
        }

        .interface-container {
          position: relative; /* Changed from fixed to allow content scroll if necessary, though overflow hidden on body */
          width: 100%;
          height: 100vh;
          z-index: 2;
          pointer-events: none; /* Allows clicks to pass through to Three.js canvas unless an element below has pointer-events: auto */
          padding: 1rem; /* Unified padding */
          display: flex;
          flex-direction: column;
          justify-content: space-between;
        }

        .grid-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: linear-gradient(
              to right,
              var(--grid-color) 1px,
              transparent 1px
            ),
            linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
          background-size: 30px 30px; /* Slightly smaller grid */
          pointer-events: none;
          z-index: 0; /* Behind UI panels but above background */
        }

        .header {
          display: flex;
          justify-content: space-between;
          padding: 0.5rem 1rem; /* Adjusted padding */
          position: relative; /* Ensure it's above grid if z-index not enough */
          z-index: 5;
        }

        .header-item {
          font-size: 0.7rem; /* Smaller header text */
          color: var(--text-secondary);
        }
        
        /* Central Scanner Frame - adapted from visualizer */
        .scanner-frame {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 350px; /* Adjusted size */
          height: 350px;
          border: 1px solid var(--accent-primary);
          box-shadow: 0 0 15px var(--accent-primary), inset 0 0 15px var(--accent-primary);
          pointer-events: none;
          z-index: 3; /* Above grid, below panels */
        }

        .scanner-frame::before,
        .scanner-frame::after,
        .scanner-frame .corner-tl,
        .scanner-frame .corner-tr,
        .scanner-frame .corner-bl,
        .scanner-frame .corner-br {
          content: "";
          position: absolute;
          width: 20px;
          height: 20px;
          border-color: var(--accent-primary);
          border-style: solid;
        }
        .scanner-frame .corner-tl { top: -2px; left: -2px; border-width: 2px 0 0 2px; }
        .scanner-frame .corner-tr { top: -2px; right: -2px; border-width: 2px 2px 0 0; }
        .scanner-frame .corner-bl { bottom: -2px; left: -2px; border-width: 0 0 2px 2px; }
        .scanner-frame .corner-br { bottom: -2px; right: -2px; border-width: 0 2px 2px 0; }

        .scanner-id {
          position: absolute;
          bottom: -25px; /* Adjusted position */
          left: 0;
          font-size: 0.65rem;
          color: var(--accent-primary);
          background-color: var(--bg-color); /* Add bg to prevent overlap issues */
          padding: 2px 4px;
        }

        .scanner-id-right {
          position: absolute;
          bottom: -25px;
          right: 0;
          font-size: 0.65rem;
          color: var(--accent-primary);
          background-color: var(--bg-color);
          padding: 2px 4px;
        }

        /* General Panel Styling - adapted from visualizer */
        .ui-panel, .data-panel, .control-panel, .terminal-panel, .spectrum-analyzer {
          background: var(--panel-bg);
          border: 1px solid var(--panel-border);
          border-radius: 5px;
          padding: 0.8rem;
          backdrop-filter: blur(10px);
          -webkit-backdrop-filter: blur(10px);
          pointer-events: auto; /* Crucial for interaction */
          box-shadow: 0 0 15px rgba(0,0,0,0.3);
          position: absolute; /* Needed for Draggable */
          z-index: 10; /* Default z-index for panels */
        }
        
        .panel-header-title {
            font-size: 0.8rem;
            color: var(--accent-primary);
            margin-bottom: 0.75rem;
            display: block; /* Make it block for better spacing */
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 0.5rem;
        }

        .panel-handle { /* For drag functionality */
          cursor: move;
          padding: 0.2rem 0.5rem;
          color: var(--accent-secondary);
          font-size: 1.2rem;
          position: absolute;
          top: 0.5rem;
          right: 0.5rem;
        }
        .panel-handle:hover {
            color: var(--accent-primary);
        }
        
        .control-group { margin-bottom: 0.8rem; }
        .control-group label, .control-label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        .control-row { /* For sliders mostly */
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.2rem;
        }
        .control-value { font-size: 0.7rem; color: var(--text-primary); }

        .slider {
          -webkit-appearance: none;
          appearance: none;
          width: 100%;
          height: 6px;
          background: rgba(255, 255, 255, 0.1);
          outline: none;
          border-radius: 3px;
          margin-top: 0.2rem;
        }
        .slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: var(--accent-primary);
          cursor: pointer;
          border: 2px solid var(--bg-color); /* Thumb border */
        }
        .slider::-moz-range-thumb {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: var(--accent-primary);
          cursor: pointer;
          border: 2px solid var(--bg-color);
        }

        .btn {
          flex: 1;
          padding: 0.6rem 0.5rem;
          background: var(--panel-highlight);
          border: 1px solid var(--panel-border);
          color: var(--accent-primary);
          font-size: 0.7rem;
          border-radius: 3px;
          cursor: pointer;
          transition: all 0.2s ease;
          text-transform: uppercase;
        }
        .btn:hover { background: var(--panel-border); color: var(--text-primary); }
        .btn:disabled { background-color: #333; cursor: not-allowed; color: #777; }
        .button-group { display: flex; gap: 0.5rem; margin-top: 0.8rem; }


        /* Maze Controls Panel (Original adapted) */
        #maze-controls-panel {
            width: 280px; /* Adjust as needed */
            top: 20px;
            left: 20px;
        }

        /* Anomaly Metrics Panels (from visualizer) */
        .data-panel { width: 280px; } /* Consistent width */
        #anomaly-metrics-left { top: 20px; left: calc(20px + 280px + 20px); /* Position next to maze controls */ }
        #anomaly-metrics-right { top: 20px; right: 20px; }

        .data-readouts { margin-top: 0.5rem; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 0.25rem; font-size: 0.7rem; }
        .data-label { color: var(--text-secondary); }
        .data-value { color: var(--text-primary); }
        .data-bar { height: 5px; background: rgba(255, 255, 255, 0.1); margin: 0.5rem 0; border-radius: 3px; }
        .data-bar-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        #status-indicator { font-size: 1.2em; transition: color 0.3s ease; }
        .waveform { width: 100%; height: 40px; margin: 0.5rem 0; background: rgba(0,0,0,0.2); border-radius: 3px; }
        .waveform-canvas { width: 100%; height: 100%; }

        /* Anomaly Controls / Maze Dynamics Panel (New / From Visualizer) */
        #dynamic-controls-panel {
            width: 280px;
            /* FIX: Positioned below the Maze Config panel to avoid overlap */
            top: calc(20px + 390px + 20px); 
            left: 20px;
        }

        /* Terminal Panel (from visualizer) */
        .terminal-panel {
          left: 20px;
          bottom: 20px;
          width: 450px; /* Adjusted width */
          height: 140px; /* Adjusted height */

        }
        .terminal-header { /* Combined with panel-header-title and panel-handle */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--panel-border);
        }
        .terminal-header span:first-child { font-size: 0.8rem; color: var(--accent-primary); }
        #terminal-status { font-size: 0.7rem; color: var(--text-secondary); }
        .terminal-content {
          height: calc(100% - 45px); /* Adjust based on header */
          overflow-y: auto;
          font-size: 0.65rem; /* Smaller terminal font */
          color: var(--text-secondary);
          line-height: 1.5;
        }
        .terminal-line { margin-bottom: 0.2rem; word-break: break-all; }
        .command-line { color: var(--text-primary); } /* Brighter for commands */
        .typing::after { content: "▋"; animation: blink 0.7s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* Audio Spectrum Analyzer Panel (from visualizer) */
        .spectrum-analyzer {
          bottom: 20px;
          right: 20px;
          width: 320px; /* Adjusted width */
        }
        .spectrum-header { /* Combined with panel-header-title and panel-handle */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--panel-border);
        }
        .spectrum-header span:first-child { font-size: 0.8rem; color: var(--accent-primary); }
        .spectrum-content { padding: 0.5rem 0; }
        .spectrum-canvas { width: 100%; height: 80px; display: block; background: rgba(0,0,0,0.1); border-radius: 3px; }
        .audio-controls { display: flex; flex-direction: column; gap: 0.6rem; margin-top: 0.75rem; }
        .audio-file-input { display: none; }
        .audio-file-btn { display: block; text-align: center; } /* Uses .btn styling */
        .audio-file-label {
            padding: 0.5rem; background: rgba(0,0,0,0.2); color: var(--accent-secondary);
            font-size: 0.65rem; border-radius: 3px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .demo-tracks-label { font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.3rem; display: block; }
        .demo-track-buttons { display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .demo-track-btn { padding: 0.4rem 0.6rem; font-size: 0.65rem; } /* Uses .btn styling */
        .demo-track-btn.active { background: var(--accent-primary); color: var(--bg-color); border-color: var(--accent-primary); }

        /* Loading Overlay (from visualizer) */
        .loading-overlay {
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background: var(--bg-color); display: flex; justify-content: center; align-items: center;
          z-index: 1000; transition: opacity 0.5s ease-out;
        }
        .loading-container { display: flex; flex-direction: column; align-items: center; }
        .preloader-canvas-container { width: 150px; height: 150px; position: relative; }
        .preloader-canvas { width: 100%; height: 100%; }
        .loading-text { margin-top: 1rem; color: var(--accent-primary); letter-spacing: 1.5px; font-size: 0.8rem; }

        /* Notification (from visualizer) */
        .notification {
          position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
          background: var(--panel-bg); border: 1px solid var(--panel-border);
          padding: 0.75rem 1.25rem; border-radius: 5px; font-size: 0.75rem;
          color: var(--accent-primary); opacity: 0; transition: opacity 0.3s ease-out, top 0.3s ease-out;
          z-index: 1001; pointer-events: none;
        }
        .notification.show { opacity: 1; top: 30px; }

/* make the <video> cover the screen behind everything */
#bg-video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  z-index: -1;           /* sit behind all your panels */
  pointer-events: none;  /* clicks “pass through” */
}

    </style>
</head>
<body>


<!-- in your <body>, at the very top -->
<video
  id="bg-video"
  playsinline
  autoplay
  muted
  loop
  
>
  <source src="rd.mp4" type="video/mp4">
  <!-- fallback for non-HTML5 browsers -->
  Your browser doesn’t support HTML5 video.
</video>
    <!-- Visualizer Backgrounds & Overlays -->
<div class="space-background"></div>
<div class="grid-overlay"></div>
<div id="three-container"></div> <!-- Maze will be rendered here -->

<!-- Loading Overlay -->  
<div class="loading-overlay" id="loading-overlay">  
  <div class="loading-container">  
    <div class="preloader-canvas-container">  
      <canvas id="preloader-canvas" class="preloader-canvas" width="180" height="180"></canvas>  
    </div>  
    <div class="loading-text">INITIALIZING SYSTEM...</div>  
  </div>  
</div>  

<!-- Notification -->  
<div class="notification" id="notification">Notification Message</div>  

<!-- Floating Particles Container -->  
<div class="floating-particles" id="floating-particles"></div>  

<!-- Main Interface Container -->  
<div class="interface-container">  
  <div class="header">  
    <div class="header-item">MAZE VISUALIZER MK.II</div>  
    <div class="header-item">SYS.AUDIO.REACTIVE.ENGINE<br />v1.0.release</div>  
    <div class="header-item" id="timestamp">TIME: 00:00:00</div>  
  </div>  

  <!-- Central Scanner Frame (visual only) -->  
  <div class="scanner-frame" id="scanner-frame">  
    <div class="corner-tl"></div><div class="corner-tr"></div>  
    <div class="corner-bl"></div><div class="corner-br"></div>  
    <div class="scanner-id" id="scanner-id-left">MAZE.GENERATOR.ACTIVE</div>  
    <div class="scanner-id-right" id="scanner-id-right">PATHFINDER.ENGAGED</div>  
  </div>  
</div>  

<!-- Maze Generator Controls (Adapted from original #ui-panel) -->  
<div class="ui-panel" id="maze-controls-panel">  
    <div class="panel-header-title">Maze Configuration</div>  
    <span class="panel-handle" id="maze-controls-panel-handle">⋮⋮</span>

<div id="ui-content">  
    <div class="control-group">  
        <div class="control-row">  
            <label for="mazeWidth" class="control-label">Width:</label>  
            <span class="control-value" id="mazeWidth-value">35</span>  
        </div>  
        <input type="range" id="mazeWidth" value="35" min="4" max="50" step="2" class="slider">  
    </div>  
    <div class="control-group">  
        <div class="control-row">  
            <label for="mazeHeight" class="control-label">Height:</label>  
            <span class="control-value" id="mazeHeight-value">35</span>  
        </div>  
        <input type="range" id="mazeHeight" value="35" min="4" max="50" step="2" class="slider">  
    </div>  
    <div class="control-group">  
        <div class="control-row">  
            <label for="cellSize" class="control-label">Cell Size:</label>  
            <span class="control-value" id="cellSize-value">8</span>  
        </div>  
        <input type="range" id="cellSize" value="8" min="2" max="30" step="1" class="slider">  
    </div>  
    <div class="control-group">  
        <div class="control-row">  
            <label for="wallHeight" class="control-label">Wall Height:</label>  
            <span class="control-value" id="wallHeight-value">2</span>  
        </div>  
        <input type="range" id="wallHeight" value="2" min="1" max="20" step="1" class="slider">  
    </div>  
</div>  
            <div class="button-group">  
                <button id="generateBtn" class="btn">Generate Maze</button>  
                <button id="solveBtn" class="btn" disabled>Solve Maze</button>  
            </div>  
            <div class="control-group" style="margin-top: 10px; display: flex; align-items: center; justify-content: flex-start;">  
                <input type="checkbox" id="instantSolveCheck" style="width: auto; margin-right: 8px; margin-top:0;">  
                <label for="instantSolveCheck" style="margin-bottom: 0; font-size: 0.7rem; display: inline-block; width:auto;">Solve Instantly</label>  
            </div>  
            <hr style="border: 0; border-top: 1px solid var(--panel-border); margin: 10px 0;">  
            <div class="button-group">  
                <button id="frameViewBtn" class="btn secondary">Frame View</button>  
                <button id="clearBtn" class="btn secondary" style="background-color: var(--accent-secondary);">Clear</button>  
            </div>  
        </div>  
    </div>  <!-- Anomaly Metrics Left (Adapted from Visualizer) -->  
<div class="data-panel" id="anomaly-metrics-left">  
    <div class="panel-header-title">System Metrics</div>  
    <span class="panel-handle" id="metrics-left-handle">⋮⋮</span>  
    <div class="data-bar"><div class="data-bar-fill" id="stability-bar" style="width: 75%;"></div></div>  
    <div class="data-readouts">  
        <div class="data-row"><span class="data-label">STABILITY INDEX:</span><span class="data-value" id="stability-value">75%</span></div>  
        <div class="data-row"><span class="data-label">WALL COUNT:</span><span class="data-value" id="wall-count-value">0</span></div>  
        <div class="data-row"><span class="data-label">PATH LENGTH:</span><span class="data-value" id="path-length-value">0</span></div>  
        <div class="data-row"><span class="data-label">COMPLEXITY:</span><span class="data-value" id="complexity-value">N/A</span></div>  
    </div>  
     <div id="status-indicator" style="color: var(--accent-primary); text-align: right; margin-top: 5px;">● OPERATIONAL</div>  
</div>  
  
<!-- Anomaly Metrics Right (Adapted from Visualizer for Audio) -->  
<div class="data-panel" id="anomaly-metrics-right">  
    <div class="panel-header-title">Audio Analysis</div>  
    <span class="panel-handle" id="metrics-right-handle">⋮⋮</span>  
    <div class="waveform"><canvas id="waveform-canvas" class="waveform-canvas"></canvas></div>  
    <div class="data-readouts">  
        <div class="data-row"><span class="data-label">PEAK FREQ:</span><span class="data-value" id="peak-value">0 HZ</span></div>  
        <div class="data-row"><span class="data-label">AMPLITUDE:</span><span class="data-value" id="amplitude-value">0.00</span></div>  
        <div class="data-row"><span class="data-label">AUDIO ENERGY:</span><span class="data-value" id="audio-energy-value">0.00</span></div>  
    </div>  
</div>  

<!-- Maze Dynamics / Anomaly Controls Panel -->  
<div class="control-panel" id="dynamic-controls-panel">  
    <div class="panel-header-title">Dynamic Modulators</div>  
    <span class="panel-handle" id="dynamic-controls-handle">⋮⋮</span>  
    <div class="control-group">  
        <div class="control-row"><label class="control-label">WALL DEFORMATION</label><span class="control-value" id="wall-deformation-value">0.0</span></div>  
        <input type="range" min="0" max="2" value="0" step="0.05" class="slider" id="wall-deformation-slider">  
    </div>  
    <div class="control-group">  
        <div class="control-row"><label class="control-label">DEFORMATION SPEED</label><span class="control-value" id="deformation-speed-value">0.1</span></div>  
        <input type="range" min="0.01" max="0.5" value="0.1" step="0.01" class="slider" id="deformation-speed-slider">  
    </div>  
    <div class="control-group">  
        <div class="control-row"><label class="control-label">COLOR INTENSITY</label><span class="control-value" id="color-intensity-value">0.5</span></div>  
        <input type="range" min="0" max="1.5" value="0.5" step="0.05" class="slider" id="color-intensity-slider">  
    </div>  
     <div class="control-group">  
        <div class="control-row"><label class="control-label">AUDIO REACTIVITY</label><span class="control-value" id="audio-reactivity-value">1.0</span></div>  
        <input type="range" min="0" max="3" value="1" step="0.1" class="slider" id="audio-reactivity-slider">  
    </div>  
</div>  
  
<!-- System Terminal -->  
<div class="terminal-panel" id="terminal-panel">  
    <div class="terminal-header">  
        <span>SYSTEM TERMINAL</span>  
        <span id="terminal-status">STANDBY</span>  
    </div>  
    <span class="panel-handle" id="terminal-handle">⋮⋮</span>  
    <div class="terminal-content" id="terminal-content">  
        <div class="terminal-line">SYSTEM BOOTING... MAZE VISUALIZER MK.II ONLINE.</div>  
        <div class="terminal-line typing"></div>  
    </div>  
</div>  

<!-- Audio Spectrum Analyzer Panel -->  
<div class="spectrum-analyzer" id="spectrum-analyzer-panel">  
    <div class="spectrum-header">  
        <span>AUDIO SPECTRUM & CONTROLS</span>  
    </div>  
    <span class="panel-handle" id="spectrum-handle">⋮⋮</span>  
    <div class="spectrum-content"><canvas id="spectrum-canvas" class="spectrum-canvas"></canvas></div>  
    <div class="audio-controls">  
        <div class="demo-tracks">  
            <span class="demo-tracks-label">DEMO TRACKS:</span>  
            <div class="demo-track-buttons">  
                <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Merkaba.mp3">MERKABA</button>  
                <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Dhamika.mp3">DHAMIKA</button>  
                <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/Vacant.mp3">VACANT</button>  
                <button class="btn demo-track-btn" data-url="https://assets.codepen.io/7558/lxstnght-back_1.mp3">LXSTNGHT</button>  
            </div>  
        </div>  
        <input type="file" id="audio-file-input" class="audio-file-input" accept="audio/*">  
        <button class="btn audio-file-btn" id="file-btn">UPLOAD AUDIO FILE</button>  
        <div class="audio-file-label" id="file-label">NO FILE SELECTED</div>  
        <audio id="audio-player" class="audio-player" crossorigin="anonymous" controls></audio>  
         <div class="control-group">  
            <div class="control-row"><label class="control-label">AUDIO SENSITIVITY</label><span class="control-value" id="audio-sensitivity-value">5.0</span></div>  
            <input type="range" min="1" max="10" value="5" step="0.1" class="slider" id="audio-sensitivity-slider">  
        </div>  
    </div>  
</div>  

<script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js'></script>  
<script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/Draggable.min.js'></script>  
<script src='https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/InertiaPlugin.min.js'></script>  
  
<script type="importmap">  
    {  
        "imports": {  
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",  
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"  
        }  
    }  
</script>


<script>
  window.addEventListener('DOMContentLoaded', () => {
    gsap.registerPlugin(Draggable, InertiaPlugin);

    const panels = [
      "#maze-controls-panel",
      "#anomaly-metrics-left",
      "#anomaly-metrics-right",
      "#dynamic-controls-panel",
      "#terminal-panel",
      "#spectrum-analyzer-panel"
    ];

    panels.forEach(selector => {
      Draggable.create(selector, {
        type: "x,y",
        edgeResistance: 0.85,
        inertia: true,
        bounds: document.body,
        allowContextMenu: true
      });
    });
  });
</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls, clock;
        let mazeGroup = new THREE.Group();
        let pathObject = null;
        const mazeData = { grid: null, start: null, end: null, solutionPath: null, wallMeshes: [], floorMesh: null };
        
        let audioContext = null, audioAnalyser = null, audioSource = null;
        let audioDataArray, frequencyDataArray;
        let isAudioInitialized = false, isAudioPlaying = false, audioContextStarted = false;
        let currentAudioElement = null;
        let isMazeGeneratedForSong = false;

        let wallDeformationAmount = 0.4, deformationSpeed = 0.1, colorIntensity = 0.5;
        let audioReactivityFactor = 1.0, audioSensitivityFactor = 5.0;

        // --- UI ELEMENTS ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const preloaderCanvas = document.getElementById('preloader-canvas');
        const notificationElement = document.getElementById('notification');
        const timestampElement = document.getElementById('timestamp');

        // Maze Controls
        const generateBtn = document.getElementById('generateBtn');
        const solveBtn = document.getElementById('solveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const frameViewBtn = document.getElementById('frameViewBtn');
        const instantSolveCheck = document.getElementById('instantSolveCheck');
        const mazeWidthInput = document.getElementById('mazeWidth');
        const mazeHeightInput = document.getElementById('mazeHeight');
        const cellSizeInput = document.getElementById('cellSize');
        const wallHeightInput = document.getElementById('wallHeight');
        const mazeWidthValue = document.getElementById('mazeWidth-value');
        const mazeHeightValue = document.getElementById('mazeHeight-value');
        const cellSizeValue = document.getElementById('cellSize-value');
        const wallHeightValue = document.getElementById('wallHeight-value');


        // Dynamic Controls
        const wallDeformationSlider = document.getElementById('wall-deformation-slider');
        const wallDeformationValue = document.getElementById('wall-deformation-value');
        const deformationSpeedSlider = document.getElementById('deformation-speed-slider');
        const deformationSpeedValue = document.getElementById('deformation-speed-value');
        const colorIntensitySlider = document.getElementById('color-intensity-slider');
        const colorIntensityValue = document.getElementById('color-intensity-value');
        const audioReactivitySlider = document.getElementById('audio-reactivity-slider');
        const audioReactivityValue = document.getElementById('audio-reactivity-value');

        // Audio Controls
        const audioFileInput = document.getElementById('audio-file-input');
        const fileBtn = document.getElementById('file-btn');
        const fileLabel = document.getElementById('file-label');
        const demoTrackBtns = document.querySelectorAll('.demo-track-btn');
        currentAudioElement = document.getElementById('audio-player');
        const audioSensitivitySlider = document.getElementById('audio-sensitivity-slider');
        const audioSensitivityValue = document.getElementById('audio-sensitivity-value');

        // Metrics Display
        const stabilityValueElement = document.getElementById('stability-value');
        const stabilityBarElement = document.getElementById('stability-bar');
        const wallCountValueElement = document.getElementById('wall-count-value');
        const pathLengthValueElement = document.getElementById('path-length-value');
        const complexityValueElement = document.getElementById('complexity-value');
        const peakValueElement = document.getElementById('peak-value');
        const amplitudeValueElement = document.getElementById('amplitude-value');
        const audioEnergyValueElement = document.getElementById('audio-energy-value');
        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrum-canvas');
        const spectrumCtx = spectrumCanvas.getContext('2d');
        
        // Terminal
        const terminalContent = document.getElementById('terminal-content');
        const terminalTypingLine = terminalContent.querySelector('.typing');
        const terminalStatus = document.getElementById('terminal-status');
        let terminalMessageQueue = [];

        // --- PRELOADER (From Visualizer) ---
        function setupExpandingCirclesPreloader() {
            if (!preloaderCanvas) return;
            const ctx = preloaderCanvas.getContext("2d");
            const centerX = preloaderCanvas.width / 2;
            const centerY = preloaderCanvas.height / 2;
            let time = 0, lastTime = 0;
            const maxRadius = 70, circleCount = 4, dotCount = 16;

            function animatePreloader(timestamp) {
              if (!lastTime) lastTime = timestamp;
              const deltaTime = timestamp - lastTime;
              lastTime = timestamp;
              time += deltaTime * 0.0015;
              ctx.clearRect(0, 0, preloaderCanvas.width, preloaderCanvas.height);
              ctx.beginPath();
              ctx.arc(centerX, centerY, 2.5, 0, Math.PI * 2);
              ctx.fillStyle = "rgba60, 180, 220,0.9";
              ctx.fill();
              for (let c = 0; c < circleCount; c++) {
                const circlePhase = (time * 0.4 + c / circleCount) % 1;
                const radius = circlePhase * maxRadius;
                const opacity = 1 - circlePhase;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(60, 180, 220, ${opacity * 0.9})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                for (let i = 0; i < dotCount; i++) {
                  const angle = (i / dotCount) * Math.PI * 2;
                  const x = centerX + Math.cos(angle) * radius;
                  const y = centerY + Math.sin(angle) * radius;
                  const size = 1.5 * (1 - circlePhase * 0.5);
                  ctx.beginPath();
                  ctx.arc(x, y, size, 0, Math.PI * 2);
                  ctx.fillStyle = `rgba(60, 180, 220, ${opacity * 0.9})`;
                  ctx.fill();
                }
              }
              if (loadingOverlay.style.display !== "none") {
                requestAnimationFrame(animatePreloader);
              }
            }
            requestAnimationFrame(animatePreloader);
        }
        
        // --- NOTIFICATIONS & TERMINAL (From Visualizer) ---
        function showNotification(message, duration = 3000) {
            notificationElement.textContent = message;
            notificationElement.classList.add('show');
            setTimeout(() => {
                notificationElement.classList.remove('show');
            }, duration);
        }

        function addTerminalMessage(message, isCommand = false, typeSpeed = 20) {
            const SCRIPT_PREFIX = "SCRIPT:> ";
            if (isCommand) message = SCRIPT_PREFIX + message;
            
            const existingTyping = terminalContent.querySelector('.typing-active');
            if (existingTyping) {
                 terminalMessageQueue.push({text: message, isCommand});
                 return;
            }

            const newLine = document.createElement("div");
            newLine.className = `terminal-line ${isCommand ? 'command-line' : ''} typing-active`;
            terminalContent.insertBefore(newLine, terminalTypingLine);
            
            let charIndex = 0;
            function typeChar() {
                if (charIndex < message.length) {
                    newLine.textContent = message.substring(0, charIndex + 1) + (charIndex < message.length -1 ? '▋' : '');
                    charIndex++;
                    terminalContent.scrollTop = terminalContent.scrollHeight;
                    setTimeout(typeChar, typeSpeed);
                } else {
                    newLine.textContent = message;
                    newLine.classList.remove('typing-active');
                    processNextTerminalMessage();
                }
            }
            typeChar();
        }
        
        function processNextTerminalMessage() {
            if (terminalMessageQueue.length > 0) {
                const nextMsg = terminalMessageQueue.shift();
                addTerminalMessage(nextMsg.text, nextMsg.isCommand);
            }
        }


        // --- MAZE LOGIC ---
        function createGrid(w, h) { return Array(h).fill(null).map(() => Array(w).fill(null).map(() => ({ N: true, E: true, S: true, W: true, visited: false }))); }

        function generateMazeGrid(width, height) {
            const grid = createGrid(width, height);
            const dOp = { 'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E' };
            const dx = { 'E': 1, 'W': -1, 'N': 0, 'S': 0 };
            const dy = { 'E': 0, 'W': 0, 'N': -1, 'S': 1 };
            const stack = [[Math.floor(Math.random()*width), Math.floor(Math.random()*height)]];
            grid[stack[0][1]][stack[0][0]].visited = true;

            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1];
                const neighbors = [];
                for (const dir of ['N', 'E', 'S', 'W']) {
                    const nx = cx + dx[dir], ny = cy + dy[dir];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[ny][nx].visited) {
                        neighbors.push({ dir, x: nx, y: ny });
                    }
                }
                if (neighbors.length > 0) {
                    const { dir, x: nx, y: ny } = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[cy][cx][dir] = false;
                    grid[ny][nx][dOp[dir]] = false;
                    grid[ny][nx].visited = true;
                    stack.push([nx, ny]);
                } else {
                    stack.pop();
                }
            }
            return grid;
        }
        function getRandomPerimeterCell(w, h, exclude = null, minDistance = 0) {
            const perimeter = [];
            for (let x = 0; x < w; x++) { perimeter.push({ x, y: 0 }); perimeter.push({ x, y: h - 1 }); }
            for (let y = 1; y < h - 1; y++) { perimeter.push({ x: 0, y }); perimeter.push({ x: w - 1, y }); }
            
            let attempts = 0;
            while(attempts < 100) {
                let potentialCells = perimeter.filter(p => !exclude || p.x !== exclude.x || p.y !== exclude.y);
                if(potentialCells.length === 0) return perimeter[0] || {x:0,y:0};
                
                const cell = potentialCells[Math.floor(Math.random() * potentialCells.length)];
                
                if (exclude && minDistance > 0) {
                    const dist = Math.sqrt(Math.pow(cell.x - exclude.x, 2) + Math.pow(cell.y - exclude.y, 2));
                    if (dist >= minDistance) return cell;
                } else {
                    return cell;
                }
                attempts++;
            }
            return potentialCells[0] || perimeter[0] || {x:0,y:0};
        }
        function solveMaze(grid, start, end) {
            const w = grid[0].length, h = grid.length;
            const dx = { 'E': 1, 'W': -1, 'N': 0, 'S': 0 };
            const dy = { 'E': 0, 'W': 0, 'N': -1, 'S': 1 };
            const q = [start];
            const visited = new Set([`${start.x},${start.y}`]);
            const parentMap = new Map();
            let pathFound = false;

            while (q.length > 0) {
                const curr = q.shift();
                if (curr.x === end.x && curr.y === end.y) { pathFound = true; break; }
                for (const dir of ['N', 'E', 'S', 'W']) {
                    if (!grid[curr.y][curr.x][dir]) {
                        const nx = curr.x + dx[dir], ny = curr.y + dy[dir];
                        const key = `${nx},${ny}`;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h && !visited.has(key)) {
                            visited.add(key);
                            parentMap.set(key, curr);
                            q.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            if (!pathFound) return [];
            const path = [];
            let curr = end;
            while (curr) {
                path.unshift(curr);
                curr = parentMap.get(`${curr.x},${curr.y}`);
            }
            return (path[0].x === start.x && path[0].y === start.y) ? path : [];
        }
        function isPathUninteresting(path) {
             if (!path || path.length < 3) return true;
            const isHorizontal = path.every(p => p.y === path[0].y);
            const isVertical = path.every(p => p.x === path[0].x);
            return isHorizontal || isVertical;
        }

        // --- THREE.JS INITIALIZATION (Merged) ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0e17, 0.035);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 500000);
            camera.position.set(0, 80, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('three-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 60000;
            controls.target.set(0,0,0);

const ambientLight = new THREE.AmbientLight(0x707080, 30.8);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffeedd, 15.2);
            dirLight.position.set(70, 100, 60);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 250; dirLight.shadow.camera.bottom = -250;
            dirLight.shadow.camera.left = -250; dirLight.shadow.camera.right = 250;
            dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 500;
            scene.add(dirLight);

            const pointLight1 = new THREE.PointLight(varToHex(getCSSVariableValue('--accent-primary')), 35.7, 3000, 1.5);
            pointLight1.position.set(50, 30, 50);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(varToHex(getCSSVariableValue('--accent-secondary')), 20.5, 2050, 1.8);
            pointLight2.position.set(-50, 2000, -50);
            scene.add(pointLight2);
            
            scene.add(mazeGroup);
            clock = new THREE.Clock();
            
            addEventListeners();
            animate();
            addTerminalMessage("3D RENDERER INITIALIZED.", false, 10);
        }

        function varToHex(colorString) {
            if (colorString.startsWith('#')) return parseInt(colorString.replace("#", "0x"));
            if (colorString.startsWith('rgb')) {
                const parts = colorString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                if (!parts) return 0xffffff;
                delete parts[0];
                for (let i = 1; i <= 3; ++i) {
                    parts[i] = parseInt(parts[i]).toString(16);
                    if (parts[i].length === 1) parts[i] = '0' + parts[i];
                }
                return parseInt("0x" + parts.join(''));
            }
            return 0xffffff;
        }

        function getCSSVariableValue(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        // --- MAZE DRAWING ---
        function draw3DMaze(grid, start, end, cellSize, wallHeight) {
            clearSceneContent();
            mazeData.wallMeshes = [];
            
            const width = grid[0].length;
            const height = grid.length;
            const wallThickness = cellSize * 0.1;

            const wallMat = new THREE.MeshStandardMaterial({
                color: varToHex(getCSSVariableValue('--text-secondary')),
                roughness: 0.7, metalness: 0.2, emissive: 0x000000,
            });
            const wallGeo = new THREE.BoxGeometry(1, 1, 1); // Unit geometry

            const createWall = (posX, posY, posZ, scaleX, scaleY, scaleZ) => {
                const wall = new THREE.Mesh(wallGeo, wallMat.clone());
                wall.scale.set(scaleX, scaleY, scaleZ);
                wall.position.set(posX, posY, posZ);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.userData.originalVertices = wall.geometry.attributes.position.array.slice(); // Store unit vertices
                
                // --- ADDITION 1 of 2: Store original Y position for ripple effect ---
                wall.userData.originalY = posY;

                // For grow-in animation
                wall.scale.y = 0.001;
                gsap.to(wall.scale, { y: scaleY, duration: 1.5, ease: 'elastic.out(1, 0.5)', delay: Math.random() * 1.0 });

                mazeGroup.add(wall);
                mazeData.wallMeshes.push(wall);
            };

            // Draw inner walls
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    if (cell.E && x < width - 1) {
                        createWall((x + 1) * cellSize, wallHeight / 2, y * cellSize + cellSize / 2, wallThickness, wallHeight, cellSize);
                    }
                    if (cell.S && y < height - 1) {
                        createWall(x * cellSize + cellSize / 2, wallHeight / 2, (y + 1) * cellSize, cellSize, wallHeight, wallThickness);
                    }
                }
            }

            // Draw border walls, excluding start/end openings
            const wallIsGap = (x, y, target) => (target.x === x && target.y === y);
            for(let x = 0; x < width; x++) {
                 if (!wallIsGap(x, 0, start) && !wallIsGap(x, 0, end)) {
                     createWall(x * cellSize + cellSize / 2, wallHeight / 2, 0, cellSize, wallHeight, wallThickness);
                 }
                 if (!wallIsGap(x, height - 1, start) && !wallIsGap(x, height - 1, end)) {
                     createWall(x * cellSize + cellSize / 2, wallHeight / 2, height * cellSize, cellSize, wallHeight, wallThickness);
                 }
            }
            for(let y = 0; y < height; y++) {
                 if (!wallIsGap(0, y, start) && !wallIsGap(0, y, end)) {
                    createWall(0, wallHeight/2, y * cellSize + cellSize/2, wallThickness, wallHeight, cellSize);
                 }
                 if (!wallIsGap(width - 1, y, start) && !wallIsGap(width - 1, y, end)) {
                    createWall(width * cellSize, wallHeight/2, y * cellSize + cellSize/2, wallThickness, wallHeight, cellSize);
                 }
            }
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(width * cellSize, height * cellSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x403833, roughness: 0.9, metalness: 0.1 });
            mazeData.floorMesh = new THREE.Mesh(floorGeo, floorMat);
            mazeData.floorMesh.rotation.x = -Math.PI / 2;
            mazeData.floorMesh.position.set((width * cellSize) / 2, 0, (height * cellSize) / 2);
            mazeData.floorMesh.receiveShadow = true;
            //mazeGroup.add(mazeData.floorMesh);

            // Start/End Markers
            [start, end].forEach((point, index) => {
                const markerGeo = new THREE.CylinderGeometry(cellSize * 0.3, cellSize * 0.3, 0.5, 16);
                const markerMat = new THREE.MeshStandardMaterial({
                    color: index === 0 ? 0x44ff44 : 0xff4444,
                    emissive: index === 0 ? 0x22aa22 : 0xaa2222,
                    emissiveIntensity: 1, roughness: 0.4
                });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.set(point.x * cellSize + cellSize/2, 0.25, point.y * cellSize + cellSize/2);
                marker.castShadow = true;
                mazeGroup.add(marker);
            });

            // Center the mazeGroup
            const box = new THREE.Box3().setFromObject(mazeGroup);
            const center = box.getCenter(new THREE.Vector3());
            mazeGroup.position.sub(center);
            
            addTerminalMessage(`MAZE GENERATED: ${width}x${height}, ${mazeData.wallMeshes.length} WALLS.`);
            updateMazeMetrics();
        }
        
        function drawAnimatedPath(path, cellSize) {
    clearPathObject();
    if (!path || path.length < 1) return;
    
    pathObject = new THREE.Group();
    pathObject.name = 'solution_path_group';
    mazeGroup.add(pathObject);
    
    const pathMat = new THREE.MeshStandardMaterial({
        color: varToHex(getCSSVariableValue('--accent-tertiary')),
        emissive: varToHex(getCSSVariableValue('--accent-primary')),
        emissiveIntensity: 1.5,
        side: THREE.DoubleSide,
        depthTest: false,
        transparent: true,
        opacity: 0.8,
        roughness: 0.5
    });
    
    const pathGeo = new THREE.BoxGeometry(cellSize * 0.7, 0.2, cellSize * 0.7);
    let i = 0;
    const baseInterval = 50;
    
    function addSegment() {
        if (i >= path.length) {
            addTerminalMessage("PATH SOLUTION ANIMATION COMPLETE.");
            return;
        }
        
        const cell = path[i];
        const segment = new THREE.Mesh(pathGeo, pathMat.clone());
        segment.position.set(
            cell.x * cellSize + cellSize / 2,
            0.1,
            cell.y * cellSize + cellSize / 2
        );
        pathObject.add(segment);
        i++;
        
        let currentInterval = baseInterval;
        if (isAudioPlaying && audioAnalyser && frequencyDataArray) {
            let sum = 0;
            for (let k = 0; k < frequencyDataArray.length / 4; k++) sum += frequencyDataArray[k];
            let avg = sum / (frequencyDataArray.length / 4);
            currentInterval = baseInterval / (1 + (avg / 255 * audioReactivityFactor * 0.5));
            currentInterval = Math.max(10, currentInterval);
        }
        
        setTimeout(addSegment, currentInterval);
    }
    
    addSegment();
}

function drawInstantPath(path, cellSize) {
    clearPathObject();
    if (!path || path.length < 1) return;

    pathObject = new THREE.Group();
    pathObject.name = 'solution_path_group';
    mazeGroup.add(pathObject);

    const pathMat = new THREE.MeshStandardMaterial({
        color: varToHex(getCSSVariableValue('--accent-tertiary')),
        emissive: varToHex(getCSSVariableValue('--accent-primary')),
        emissiveIntensity: 1.5,
        side: THREE.DoubleSide,
        depthTest: false,
        transparent: true,
        opacity: 0.8,
        roughness: 0.5
    });

    const pathGeo = new THREE.BoxGeometry(cellSize * 0.7, 0.2, cellSize * 0.7);

    for (const cell of path) {
        const segment = new THREE.Mesh(pathGeo, pathMat.clone());
        segment.position.set(
            cell.x * cellSize + cellSize / 2,
            0.1,
            cell.y * cellSize + cellSize / 2
        );
        pathObject.add(segment);
    }

    addTerminalMessage("PATH SOLUTION DRAWN INSTANTLY.");
}

        // --- AUDIO PROCESSING ---
        function initAudioSystem() {
            if (isAudioInitialized) return true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 1024;
                audioAnalyser.smoothingTimeConstant = 0.7;
                audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                frequencyDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                isAudioInitialized = true;
                addTerminalMessage("AUDIO SUBSYSTEM INITIALIZED.");
                terminalStatus.textContent = "AUDIO READY";
                return true;
            } catch (error) {
                console.error("Audio initialization error:", error);
                addTerminalMessage("ERROR: AUDIO SUBSYSTEM FAILED. " + error.message, true);
                showNotification("AUDIO SYSTEM ERROR");
                terminalStatus.textContent = "AUDIO ERROR";
                return false;
            }
        }

        function ensureAudioContextStarted() {
            if (!audioContext) {
                if (!initAudioSystem()) return false;
            }
            if (audioContext.state === "suspended") {
                audioContext.resume().then(() => {
                    if (!audioContextStarted) {
                        audioContextStarted = true;
                        addTerminalMessage("AUDIO CONTEXT RESUMED.");
                    }
                }).catch(err => {
                    addTerminalMessage("ERROR: FAILED TO RESUME AUDIO. " + err.message, true);
                });
            } else {
                audioContextStarted = true;
            }
            return audioContextStarted;
        }
        
        function setupAudioSource(audioElement) {
            if (!ensureAudioContextStarted()) {
                addTerminalMessage("ERROR: AUDIO CONTEXT NOT READY.", true);
                return false;
            }
            if (audioSource) {
                audioSource.disconnect();
            }
            try {
                audioSource = audioContext.createMediaElementSource(audioElement);
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                addTerminalMessage("AUDIO SOURCE CONNECTED: " + (audioElement.src.substring(0,50) || "HTMLMediaElement"));
                return true;
            } catch (error) {
                 addTerminalMessage("ERROR SETTING UP AUDIO SOURCE: " + error.message, true);
                 console.error("Error setting up audio source:", error);
                 return false;
            }
        }

        function playAudio(audioElement) {
            if (!isMazeGeneratedForSong) {
                handleGenerate();
                isMazeGeneratedForSong = true;
            }
            audioElement.play().catch(e => addTerminalMessage("Playback error: " + e.message, true));
        }

        function loadAudioFile(file) {
            if (!initAudioSystem()) return;
            isMazeGeneratedForSong = false;
            const fileURL = URL.createObjectURL(file);
            currentAudioElement.src = fileURL;
            fileLabel.textContent = file.name.length > 25 ? file.name.substring(0,22) + "..." : file.name;
            currentAudioElement.oncanplaythrough = () => {
                if (setupAudioSource(currentAudioElement)) {
                    playAudio(currentAudioElement);
                }
            };
            currentAudioElement.onerror = () => {
                addTerminalMessage(`ERROR LOADING AUDIO FILE: ${file.name}`, true);
                fileLabel.textContent = "LOAD ERROR";
            };
            addTerminalMessage(`LOADING AUDIO FILE: ${file.name}`);
        }

        function loadDemoTrack(url) {
            if (!initAudioSystem()) return;
            isMazeGeneratedForSong = false;
            currentAudioElement.src = url;
            const filename = url.split("/").pop();
            fileLabel.textContent = filename.length > 25 ? filename.substring(0,22) + "..." : filename;
            
            currentAudioElement.oncanplaythrough = () => {
                 if (setupAudioSource(currentAudioElement)) {
                    playAudio(currentAudioElement);
                }
            };
             currentAudioElement.onerror = () => {
                addTerminalMessage(`ERROR LOADING DEMO: ${filename}`, true);
                fileLabel.textContent = "LOAD ERROR";
            };
            addTerminalMessage(`LOADING DEMO TRACK: ${filename}`);
        }
        
        currentAudioElement.onplay = () => { isAudioPlaying = true; terminalStatus.textContent = "PLAYING"; };
        currentAudioElement.onpause = () => { isAudioPlaying = false; terminalStatus.textContent = "PAUSED"; };
        currentAudioElement.onended = () => { isAudioPlaying = false; terminalStatus.textContent = "AUDIO READY"; };


        // --- UI HANDLERS & HELPERS ---
        function updateMazeMetrics() {
            wallCountValueElement.textContent = mazeData.wallMeshes.length;
            pathLengthValueElement.textContent = mazeData.solutionPath ? mazeData.solutionPath.length : 0;
            let complexity = "N/A";
            if (mazeData.grid && mazeData.solutionPath && mazeData.solutionPath.length > 0) {
                complexity = ((mazeData.grid[0].length * mazeData.grid.length * 10) / mazeData.solutionPath.length).toFixed(1);
            }
            complexityValueElement.textContent = complexity;
        }

        function clearPathObject() {
            if (pathObject) {
                mazeGroup.remove(pathObject);
                pathObject.traverse(child => {
                    if (child.isMesh) { child.geometry.dispose(); child.material.dispose(); }
                });
                pathObject = null;
            }
        }
        function clearSceneContent() {
            clearPathObject();
            mazeData.wallMeshes = [];
            
            const toRemove = [];
            mazeGroup.children.forEach(child => toRemove.push(child));
            toRemove.forEach(child => {
                 if (child.geometry) child.geometry.dispose();
                 if (child.material) child.material.dispose();
                 mazeGroup.remove(child);
            });
            mazeData.grid = null;
            mazeData.floorMesh = null;
            solveBtn.disabled = true;
            isMazeGeneratedForSong = false;
            updateMazeMetrics();
            addTerminalMessage("SCENE CLEARED. READY FOR NEW GENERATION.");
        }
        
        function handleGenerate() {
            generateBtn.disabled = true; generateBtn.textContent = 'Generating...';
            addTerminalMessage("INITIATING MAZE GENERATION PROTOCOL...");

            setTimeout(() => {
                const width = parseInt(mazeWidthInput.value);
                const height = parseInt(mazeHeightInput.value);
                const cellSize = parseFloat(cellSizeInput.value);
                const wallH = parseFloat(wallHeightInput.value);

                let attempts = 0, isGoodMaze = false;
                do {
                    mazeData.grid = generateMazeGrid(width, height);
                    const min_dist = Math.max(width, height) / 2.5;
                    mazeData.start = getRandomPerimeterCell(width, height);
                    mazeData.end = getRandomPerimeterCell(width, height, mazeData.start, min_dist);
                    mazeData.solutionPath = solveMaze(mazeData.grid, mazeData.start, mazeData.end);
                    if (mazeData.solutionPath && mazeData.solutionPath.length > 0 && !isPathUninteresting(mazeData.solutionPath)) {
                        isGoodMaze = true;
                    }
                    attempts++;
                } while (!isGoodMaze && attempts < 30);

                if (!isGoodMaze) addTerminalMessage("WARNING: Could not generate a complex maze. Using last attempt.", true);
                
                draw3DMaze(mazeData.grid, mazeData.start, mazeData.end, cellSize, wallH);
                
                solveBtn.disabled = false;
                frameView();
                generateBtn.disabled = false; generateBtn.textContent = 'Generate Maze';
                showNotification("New Maze Generated!");
            }, 100);
        }

        function handleSolve() {
            if (!mazeData.solutionPath || mazeData.solutionPath.length === 0) {
                showNotification("No solution found for this maze!");
                addTerminalMessage("ERROR: NO SOLUTION PATH AVAILABLE.", true);
                return;
            }
            const cellSize = parseFloat(cellSizeInput.value);
            addTerminalMessage("INITIATING PATH SOLUTION SEQUENCE...");
            if (instantSolveCheck.checked) {
                drawInstantPath(mazeData.solutionPath, cellSize);
            } else {
                drawAnimatedPath(mazeData.solutionPath, cellSize);
            }
        }
        
        function frameView() {
            if (mazeGroup.children.length === 0) return;
            
            const box = new THREE.Box3().setFromObject(mazeGroup);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.8;

            gsap.to(camera.position, {
                x: center.x, y: center.y + cameraZ * 0.8, z: center.z + cameraZ,
                duration: 1, ease: "power2.out",
            });
            gsap.to(controls.target, {
                x: center.x, y: center.y, z: center.z,
                duration: 1, ease: "power2.out"
            });
            addTerminalMessage("CAMERA VIEW FRAMED ON MAZE.");
        }


        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            controls.update(delta);

            let audioLevel = 0, bassLevel = 0, midLevel = 0, trebleLevel = 0;

            if (isAudioPlaying && audioAnalyser && frequencyDataArray) {
                audioAnalyser.getByteFrequencyData(frequencyDataArray);
                audioAnalyser.getByteTimeDomainData(audioDataArray);

                let sum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const bassEndIndex = Math.floor(frequencyDataArray.length * 0.15);
                const midEndIndex = Math.floor(frequencyDataArray.length * 0.5);

                for (let i = 0; i < frequencyDataArray.length; i++) {
                    const val = frequencyDataArray[i];
                    sum += val;
                    if (i < bassEndIndex) bassSum += val;
                    else if (i < midEndIndex) midSum += val;
                    else trebleSum += val;
                }
                const sensitivity = audioSensitivityFactor / 5.0;
                audioLevel = (sum / frequencyDataArray.length / 255) * sensitivity;
                bassLevel = (bassSum / bassEndIndex / 255) * sensitivity;
                midLevel = (midSum / (midEndIndex - bassEndIndex) / 255) * sensitivity;
                trebleLevel = (trebleSum / (frequencyDataArray.length - midEndIndex) / 255) * sensitivity;

                peakValueElement.textContent = `${(frequencyDataArray.indexOf(Math.max(...frequencyDataArray)) * audioContext.sampleRate / audioAnalyser.fftSize).toFixed(0)} HZ`;
                amplitudeValueElement.textContent = audioLevel.toFixed(2);
                audioEnergyValueElement.textContent = (bassLevel * 100).toFixed(1);

                drawWaveformVisualizer(audioDataArray);
                drawSpectrumVisualizer(frequencyDataArray);

                mazeData.wallMeshes.forEach(wall => {
                    // Vertex-level deformation (from slider)
                    const currentDeform = wallDeformationAmount * audioReactivityFactor * (bassLevel * 0.6 + midLevel * 0.3 + trebleLevel * 0.1);
                    const speed = deformationSpeed * (1 + audioLevel * 2.0);

                    if (currentDeform > 0.01 && wall.userData.originalVertices) {
                        const positions = wall.geometry.attributes.position.array;
                        const originalPos = wall.userData.originalVertices;

                        for (let i = 0; i < positions.length; i += 3) {
                            const p_x = originalPos[i], p_y = originalPos[i+1], p_z = originalPos[i+2];
                            const noiseX = 0.5 * (Math.sin(p_z * 0.4 + elapsedTime * speed) + Math.cos(p_y * 0.4 + elapsedTime * speed));
                            const noiseY = 0.5 * (Math.sin(p_x * 0.4 + elapsedTime * speed) + Math.cos(p_z * 0.4 + elapsedTime * speed));
                            const noiseZ = 0.5 * (Math.sin(p_y * 0.4 + elapsedTime * speed) + Math.cos(p_x * 0.4 + elapsedTime * speed));

                            positions[i]   = p_x + noiseX * currentDeform;
                            positions[i+1] = p_y + noiseY * currentDeform;
                            positions[i+2] = p_z + noiseZ * currentDeform;
                        }
                        wall.geometry.attributes.position.needsUpdate = true;
                        wall.geometry.computeVertexNormals();
                    } else if (wall.userData.originalVertices) {
                        wall.geometry.attributes.position.array.set(wall.userData.originalVertices);
                        wall.geometry.attributes.position.needsUpdate = true;
                    }

                    // Color and emissive reactivity
                    const h = (0 + bassLevel * 30) / 360;
                    const s = 0.8 + midLevel * 0.2;
                    const l = 0.4 + trebleLevel * 0.3;
                    wall.material.color.setHSL(h, s, Math.min(0.8, l));
                    wall.material.emissive.setHSL(h, s, Math.min(0.5, l * 0.5 * colorIntensity * audioReactivityFactor));
                    wall.material.emissiveIntensity = midLevel * colorIntensity * 2.0 * audioReactivityFactor;

                    // --- ADDITION 2 of 2: NEW RIPPLE DEFORMATION LOGIC ---
                    if (wall.userData.originalY !== undefined) {
                        // Calculate distance from the center of the maze for a circular ripple effect
                        const rippleDistance = wall.position.clone().sub(mazeGroup.position).length();

                        // Define ripple parameters (you can tweak these for different looks)
                        const rippleFrequency = 0.1;   // How tight the waves are
                        const rippleSpeed = 4.0;       // How fast the waves travel outwards
                        const rippleAmplitude = 15.0;  // The maximum height of the ripple effect

                        // Calculate the vertical offset using a sine wave.
                        // The wave's amplitude is driven by the overall audio level.
                        // The phase is determined by the wall's distance from the center and the elapsed time.
                        const rippleOffset = (audioLevel * rippleAmplitude) * Math.sin(rippleDistance * rippleFrequency - elapsedTime * rippleSpeed);

                        // Apply the calculated offset to the wall's original Y position
                        wall.position.y = wall.userData.originalY + rippleOffset;
                    }
                    // --- END OF NEW RIPPLE LOGIC ---

                });
                if(mazeData.floorMesh){
                    mazeData.floorMesh.material.color.setHSL(0, 0.1, 0.1 + bassLevel * 0.1);
                }
                if (pathObject) {
                    const pathIntensity = 1.5 + bassLevel * 3.0 * audioReactivityFactor;
                    pathObject.children.forEach(seg => { if(seg.isMesh) seg.material.emissiveIntensity = pathIntensity; });
                }

            } else {
                 mazeData.wallMeshes.forEach(wall => {
                    if (wall.userData.originalVertices && wall.geometry.attributes.position.array[0] !== wall.userData.originalVertices[0]) {
                        wall.geometry.attributes.position.array.set(wall.userData.originalVertices);
                        wall.geometry.attributes.position.needsUpdate = true;
                    }
                    // Reset position if audio stops
                    if (wall.userData.originalY !== undefined) {
                        wall.position.y = wall.userData.originalY;
                    }
                    wall.material.color.set(varToHex(getCSSVariableValue('--text-secondary')));
                    wall.material.emissive.set(0x000000);
                 });
                 if(mazeData.floorMesh) mazeData.floorMesh.material.color.set(0x403833);
                 if(pathObject) pathObject.children.forEach(seg => { if(seg.isMesh) seg.material.emissiveIntensity = 1.5; });
            }
            
            const stability = 50 + (audioLevel * 100);
            stabilityBarElement.style.width = `${Math.min(100, stability)}%`;
            stabilityValueElement.textContent = `${Math.min(100, stability).toFixed(0)}%`;


            renderer.render(scene, camera);
            updateTimestampDisplay();
        }
        
        // --- VISUALIZER DRAWING FUNCTIONS ---
        function drawWaveformVisualizer(data) {
            waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            waveformCtx.fillStyle = "rgba(0,0,0,0.1)";
            waveformCtx.fillRect(0,0,waveformCanvas.width,waveformCanvas.height);
            waveformCtx.beginPath();
            waveformCtx.strokeStyle = getCSSVariableValue('--accent-primary');
            waveformCtx.lineWidth = 1.5;
            const sliceWidth = waveformCanvas.width / data.length;
            let x = 0;
            for (let i = 0; i < data.length; i++) {
                const v = data[i] / 128.0;
                const y = v * waveformCanvas.height / 2;
                if (i === 0) waveformCtx.moveTo(x, y);
                else waveformCtx.lineTo(x, y);
                x += sliceWidth;
            }
            waveformCtx.stroke();
        }

        function drawSpectrumVisualizer(data) {
            spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
            spectrumCtx.fillStyle = "rgba(0,0,0,0.1)";
            spectrumCtx.fillRect(0,0,spectrumCanvas.width,spectrumCanvas.height);
            
            const numBars = 64;
            const barWidth = spectrumCanvas.width / numBars;
            let x = 0;

            for (let i = 0; i < numBars; i++) {
                const percent = i / numBars;
                const logPercent = Math.pow(percent, 2);
                const freqIndex = Math.floor(logPercent * (data.length / 2));
                const barHeight = (data[freqIndex] / 255) * spectrumCanvas.height * (audioSensitivityFactor / 5);
                const hue = (i / numBars) * 40;
                spectrumCtx.fillStyle = `hsl(${hue}, 100%, ${50 + Math.min(20, data[freqIndex]/10)}%)`;
                spectrumCtx.fillRect(x, spectrumCanvas.height - barHeight, barWidth -1 , barHeight);
                x += barWidth;
            }
        }
        function resizeVisualizerCanvases() {
            [waveformCanvas, spectrumCanvas].forEach(canvas => {
                if (canvas) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
            });
        }
        
        // --- EVENT LISTENERS ---
        function addEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
                resizeVisualizerCanvases();
            });
            
            // Maze controls with sliders
            const setupSlider = (slider, valueLabel) => {
                valueLabel.textContent = slider.value;
                slider.addEventListener('input', () => valueLabel.textContent = slider.value);
            };
            setupSlider(mazeWidthInput, mazeWidthValue);
            setupSlider(mazeHeightInput, mazeHeightValue);
            setupSlider(cellSizeInput, cellSizeValue);
            setupSlider(wallHeightInput, wallHeightValue);
            
            generateBtn.addEventListener('click', handleGenerate);
            solveBtn.addEventListener('click', handleSolve);
            clearBtn.addEventListener('click', clearSceneContent);
            frameViewBtn.addEventListener('click', frameView);

            // Dynamic controls
            wallDeformationSlider.addEventListener('input', (e) => { wallDeformationAmount = parseFloat(e.target.value); wallDeformationValue.textContent = wallDeformationAmount.toFixed(2); });
            deformationSpeedSlider.addEventListener('input', (e) => { deformationSpeed = parseFloat(e.target.value); deformationSpeedValue.textContent = deformationSpeed.toFixed(2); });
            colorIntensitySlider.addEventListener('input', (e) => { colorIntensity = parseFloat(e.target.value); colorIntensityValue.textContent = colorIntensity.toFixed(2); });
            audioReactivitySlider.addEventListener('input', (e) => { audioReactivityFactor = parseFloat(e.target.value); audioReactivityValue.textContent = audioReactivityFactor.toFixed(1); });

            // Audio controls
            fileBtn.addEventListener('click', () => { ensureAudioContextStarted(); audioFileInput.click(); });
            audioFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) loadAudioFile(e.target.files[0]); });
            demoTrackBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    ensureAudioContextStarted();
                    demoTrackBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadDemoTrack(btn.dataset.url);
                });
            });
            audioSensitivitySlider.addEventListener('input', (e) => { audioSensitivityFactor = parseFloat(e.target.value); audioSensitivityValue.textContent = audioSensitivityFactor.toFixed(1); });
            
            // Initial values for sliders
            wallDeformationValue.textContent = wallDeformationSlider.value; wallDeformationAmount = parseFloat(wallDeformationSlider.value);
            deformationSpeedValue.textContent = deformationSpeedSlider.value; deformationSpeed = parseFloat(deformationSpeedSlider.value);
            colorIntensityValue.textContent = colorIntensitySlider.value; colorIntensity = parseFloat(colorIntensitySlider.value);
            audioReactivityValue.textContent = audioReactivitySlider.value; audioReactivityFactor = parseFloat(audioReactivitySlider.value);
            audioSensitivityValue.textContent = audioSensitivitySlider.value; audioSensitivityFactor = parseFloat(audioSensitivitySlider.value);

Draggable.create("#maze-controls-panel", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#maze-controls-panel .panel-handle"
});

Draggable.create("#anomaly-metrics-left", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#anomaly-metrics-left .panel-handle"
});

Draggable.create("#anomaly-metrics-right", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#anomaly-metrics-right .panel-handle"
});

Draggable.create("#dynamic-controls-panel", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#dynamic-controls-panel .panel-handle"
});

Draggable.create("#terminal-panel", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#terminal-panel .panel-handle"
});

Draggable.create("#spectrum-analyzer-panel", {
    type: "x,y",
    edgeResistance: 0.65,
    bounds: document.body,
    inertia: true,
    throwResistance: 2500,
    trigger: "#spectrum-analyzer-panel .panel-handle"
});

        }
        
        function updateTimestampDisplay() {
            const now = new Date();
            timestampElement.textContent = `TIME: ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
        }

        // --- INITIALIZATION ---
        function main() {
            setupExpandingCirclesPreloader();
            setTimeout(() => {
                loadingOverlay.style.opacity = 0;
                setTimeout(() => { 
                    loadingOverlay.style.display = 'none'; 
                    initAudioSystem();
                    terminalStatus.textContent = "ONLINE";
                    showNotification("System Online. Load Audio to Generate.", 4000);
                }, 500);
                
                initThree();
                // handleGenerate(); // Removed from initial load, now tied to audio playback
                resizeVisualizerCanvases();
                addTerminalMessage("SYSTEM INITIALIZED. AWAITING AUDIO INPUT.");

            }, 2500);
        }
        
        main();

    </script>
</body>
</html>